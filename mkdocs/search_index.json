{
    "docs": [
        {
            "location": "/",
            "text": "Tutorial for zeeSQL\n\n\nSetting up the environment\n\n\nIf you want to start exploring zeeSQL, this tutorial will walk you through the most important commands to know and how to use them.\n\n\nThe simplest way to follow this tutorial is to launch an instance of \nzeeSQL\n using docker.\n\n\ndocker run --name zeesql --rm -d redbeardlab/zeesql\n\n\n\n\nThe next thing you will need to follow the tutorial is the \nredis-cli\n.\n\n\nYou can connect to the same docker container and start the \nredis-cli\n with:\n\n\ndocker exec -it zeesql redis-cli\n\n\n\n\nAt this point you are inside the \nredis-cli\n, ready to interact with \nRedis\n and \nzeeSQL\n.\n\n\nCreating a database in zeeSQL\n\n\nThe very first step when working with \nzeeSQL\n it is to create a new database.\n\n\nThe database can be created with a single command.\n\n\n127.0.0.1:6379> ZEESQL.CREATE_DB DB\n1) 1) \"OK\"\n\n\n\n\nThis command will create a new database, and it will associate it with the Redis key \nDB\n.\n\n\nAny time we want to interact with this database, we will pass \nDB\n to the \nzeeSQL\n commands.\n\n\nIt is possible to create more than one database, you can create as many as you like, since they are very lightweight.\n\n\nSending commands to the database\n\n\nAfter creating a database, we want to interact with it. It is possible to interact with the database sending it commands.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select 1;' NO_HEADER\n1) 1) \"RESULT\"\n2) 1) (integer) 1\n\n\n\n\nWe have successfully sent our first command to \nzeeSQL\n and get our first \nRESULT\n, the integer 1.\n\n\nModify the database structure\n\n\nA database without tables is not very useful.\nWe will now create a table to store information about users.\n\n\nIn the table we want to store the username, its score and the user email.\nThe username and the email will be text fields, while the score will be an integer field.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'CREATE TABLE users(username TEXT, score INT, email TEXT);'\n1) 1) \"DONE\"\n2) 1) (integer) 0\n\n\n\n\nThe operation was successfully and 0 rows have been modified.\n\n\nHowever, we now have a table where we can store information about the user.\n\n\nAdd data to the database\n\n\nWe can now start to add users to our table.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'INSERT INTO users VALUES(\"jsmith\", 3, \"jon.smith@gmail.com\");'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'INSERT INTO users VALUES(\"EvelineInArgentina\", 3, \"eve.frank@yahoo.com\");'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'INSERT INTO users VALUES(\"DuffyAlone\", 12, \"mr.duffy@proton.com\");'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'INSERT INTO users VALUES(\"far\", 6, \"farrington@nv.ru\");'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n\n\n\n\nEach insert was successful and each one added one more row to the database.\n\n\nQuery the database\n\n\nAfter having added data to the database, we want to query those data back.\n\n\nWe can ask for the score of the user \njsmith\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'SELECT score FROM users WHERE username = \"jsmith\"'\n1) 1) \"RESULT\"\n2) 1) \"score\"\n3) 1) \"INT\"\n4) 1) (integer) 3\n\n\n\n\nIn this case the score is an integer, and it is of value 3.\n\n\nOr to know what users have a score greater than 5\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'SELECT username FROM users WHERE score > 5'\n1) 1) \"RESULT\"\n2) 1) \"username\"\n3) 1) \"TEXT\"\n4) 1) \"DuffyAlone\"\n5) 1) \"far\"\n\n\n\n\nIn this other case the usernames are of type TEXT and are: \nDuffyAlone\n and \nfar\n.\n\n\nSince we are not modifying the database, instead of EXECUTING a command with \nEXEC\n we can just QUERY.\n\n\n127.0.0.1:6379> ZEESQL.QUERY DB COMMAND 'SELECT username FROM users WHERE score > 5'\n1) 1) \"RESULT\"\n2) 1) \"username\"\n3) 1) \"TEXT\"\n4) 1) \"DuffyAlone\"\n5) 1) \"far\"\n\n\n\n\nQUERY\n does not work when trying to modify the database.\n\n\n127.0.0.1:6379> ZEESQL.QUERY DB COMMAND 'INSERT INTO users VALUES(\"far\", 6, \"farrington@nv.ru\");'\n(error) Statement is not read only but it may modify the database, use `EXEC_STATEMENT` instead.\n\n\n\n\nModify the data\n\n\nOur users, keep using our platform, are increasing their score. We can increase the score with an update.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'UPDATE users SET score = score + 1 WHERE username = \"jsmith\";'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.QUERY DB COMMAND 'SELECT score FROM users WHERE username = \"jsmith\"'\n1) 1) \"RESULT\"\n2) 1) \"score\"\n3) 1) \"INT\"\n4) 1) (integer) 4\n\n\n\n\nIn this example, we first increase the score of the user \njsmith\n of one, and then we query the same score.\n\n\nDelete the data\n\n\nEventually our user will leave the platform, in this case we can delete them.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'DELETE FROM users WHERE username = \"far\";'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n\n\n\n\nUse arguments for your queries\n\n\nUp to now, we send only SQL queries that contains all the parameters. \nIt is also possible to send a query with placeholders followed by arguments.\nThis is useful to avoid SQL injections attacks and to avoid string constructions at runtime.\n\n\nIn our example we can increment the score of a player by a specific amount.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'UPDATE users SET score = score + ?2 WHERE username = ?1;' ARGS jsmith 3\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.QUERY DB COMMAND 'SELECT score FROM users WHERE username = ?1' ARGS jsmith\n1) 1) \"RESULT\"\n2) 1) \"score\"\n3) 1) \"INT\"\n4) 1) (integer) 7\n\n\n\n\nThe first argument is \n?1\n (not \n?0\n) and the second argument is \n?2\n.\n\n\nUsing secondary indexes (or search by values) in Redis\n\n\nNow that we have understood how to deal with standard zeeSQL databases and how to query them, we can move forward.\n\n\nNow we will introduce zeeSQL secondary indexes, or how to search and project Redis \nhash\n data.\n\n\nIn Redis, it is common to store values as hash.\nEach hash is univocally identify by a key, and it has one of more field. \nEach field has a value associated with.\n\n\nRedis already provide fast access to elements by their key.\nBut it is not possible to search keys from their values.\n\n\nWith zeeSQL we can solve this problem, but automatically push the hashes keys and values to a specific table.\n\n\nWe will work with a simple telemetric system.\nWe have different sensors, each sensor send a timestamp, a temperature value and a humidity value.\n\n\nSaving the data into Redis\n\n\nAs first step let's see how we model the data in raw Redis, using Redis Hashes.\n\n\n127.0.0.1:6379> HMSET sensor:001:1612733809 timestamp 1612733809 sensor 1 temperature 23 humidity 56\nOK\n127.0.0.1:6379> HMSET sensor:001:1612633809 timestamp 1612633809 sensor 1 temperature 18 humidity 21\nOK\n127.0.0.1:6379> HMSET sensor:001:1612633819 timestamp 1612633819 sensor 1 temperature 20 humidity 23\nOK\n127.0.0.1:6379> HMSET sensor:002:1612733809 timestamp 1612733809 sensor 2 temperature 32 humidity 11\nOK\n127.0.0.1:6379> HMSET sensor:002:1612633809 timestamp 1612633809 sensor 2 temperature 21 humidity 16\nOK\n127.0.0.1:6379> HMSET sensor:002:1612633819 timestamp 1612633819 sensor 2 temperature 23 humidity 12\nOK\n\n\n\n\nThe key is in the form \nsensor:$sendor_id:$timestamp\n and the other fields contains the telemetries' data.\n\n\nCreating an index\n\n\nWe now want to store the information in the sensor in an SQL table, for easier access.\n\n\n127.0.0.1:6379> ZEESQL.INDEX DB NEW TABLE sensors PREFIX sensor:* SCHEMA timestamp INT sensor INT temperature INT humidity INT\nOK\n\n\n\n\nThe command creates a new secondary index associate with the table \nsensors\n.\nThe index will be concerned only for the hashes which key start with the prefix \nsensor:\n (\n*\n being a catch-all).\nThe schema used by the index will have 4 rows, each of them will be an INTEGER, and the name of those columns are respectively \ntimestamp\n. \nsensor\n, \ntemperature\n and \nhumidity\n.\n\n\nThe creation of an index, imply the creation of the table in the database.\nIf the table already exists, it is assumed to contain the correct columns.\n\n\nReading data from the index\n\n\nAs soon as the index is created, the Redis keys space is scanned and the hashes are added to the table.\nWhich means that we can immediately query the table.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select * from sensors;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"timestamp\"\n   3) \"sensor\"\n   4) \"temperature\"\n   5) \"humidity\"\n3) 1) \"TEXT\"\n   2) \"INT\"\n   3) \"INT\"\n   4) \"INT\"\n   5) \"INT\"\n4) 1) \"sensor:001:1612633809\"\n   2) (integer) 1612633809\n   3) (integer) 1\n   4) (integer) 18\n   5) (integer) 21\n5) 1) \"sensor:002:1612733809\"\n   2) (integer) 1612733809\n   3) (integer) 2\n   4) (integer) 32\n   5) (integer) 11\n6) 1) \"sensor:001:1612733809\"\n   2) (integer) 1612733809\n   3) (integer) 1\n   4) (integer) 23\n   5) (integer) 56\n7) 1) \"sensor:002:1612633819\"\n   2) (integer) 1612633819\n   3) (integer) 2\n   4) (integer) 23\n   5) (integer) 12\n8) 1) \"sensor:002:1612633809\"\n   2) (integer) 1612633809\n   3) (integer) 2\n   4) (integer) 21\n   5) (integer) 16\n9) 1) \"sensor:001:1612633819\"\n   2) (integer) 1612633819\n   3) (integer) 1\n   4) (integer) 20\n   5) (integer) 23\n\n\n\n\nModify the table of the index\n\n\nIt is possible to add, remove and update values to the index table manually.\nDo not do that,  the data between Redis and zeeSQL will go out of sync.\n\n\nAdding hashes\n\n\nThe index continuously listens to the HASH commands of Redis and keeps the table in sync.\n\n\n127.0.0.1:6379> HMSET sensor:003:1612633819 timestamp 1612633819 sensor 3 temperature 50 humidity 8\nOK\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select * from sensors where sensor = 3;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"timestamp\"\n   3) \"sensor\"\n   4) \"temperature\"\n   5) \"humidity\"\n3) 1) \"TEXT\"\n   2) \"INT\"\n   3) \"INT\"\n   4) \"INT\"\n   5) \"INT\"\n4) 1) \"sensor:003:1612633819\"\n   2) (integer) 1612633819\n   3) (integer) 3\n   4) (integer) 50\n   5) (integer) 8\n\n\n\n\nIn this example we added the sensor with ID 3, after the secondary index was already in place.\n\n\nRemoving hashes\n\n\nSimilarly, if a hash is deleted, the correct row is deleted from the table.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select key from sensors where sensor = 2;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n3) 1) \"TEXT\"\n4) 1) \"sensor:002:1612733809\"\n5) 1) \"sensor:002:1612633819\"\n6) 1) \"sensor:002:1612633809\"\n127.0.0.1:6379> DEL sensor:002:1612633809\n(integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select key from sensors where sensor = 2;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n3) 1) \"TEXT\"\n4) 1) \"sensor:002:1612733809\"\n5) 1) \"sensor:002:1612633819\"\n\n\n\n\nAs you can see we delete a hash, and the correct row was deleted also from the table.\n\n\nUpdating hashes\n\n\nAs with deletion, updating a hash is also reflected on the index table.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select key, temperature from sensors where sensor = 3;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"temperature\"\n3) 1) \"TEXT\"\n   2) \"INT\"\n4) 1) \"sensor:003:1612633819\"\n   2) (integer) 50\n127.0.0.1:6379> HINCRBY sensor:003:1612633819 temperature 33\n(integer) 83\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select key, temperature from sensors where sensor = 3;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"temperature\"\n3) 1) \"TEXT\"\n   2) \"INT\"\n4) 1) \"sensor:003:1612633819\"\n   2) (integer) 83\n\n\n\n\nIn this case we update a hash, and also the table was updated.\n\n\nQuerying the secondary index table\n\n\nThe secondary index table, it is just a plain SQL table.\nzeeSQL does not add any index on the table.\nUser is free to add the SQL indexes it desired to the secondary index table.\n\n\nWithout any index, each query will go through a full table scan.\n\n\nEnd\n\n\nI hope that this tutorial was helpful :)\n\n\nIf you have any question, feel free to contact me simone@redbeardlab.com or on github: \nRedBeardLab/zeeSQL-doc",
            "title": "Overview"
        },
        {
            "location": "/#tutorial-for-zeesql",
            "text": "",
            "title": "Tutorial for zeeSQL"
        },
        {
            "location": "/#setting-up-the-environment",
            "text": "If you want to start exploring zeeSQL, this tutorial will walk you through the most important commands to know and how to use them.  The simplest way to follow this tutorial is to launch an instance of  zeeSQL  using docker.  docker run --name zeesql --rm -d redbeardlab/zeesql  The next thing you will need to follow the tutorial is the  redis-cli .  You can connect to the same docker container and start the  redis-cli  with:  docker exec -it zeesql redis-cli  At this point you are inside the  redis-cli , ready to interact with  Redis  and  zeeSQL .",
            "title": "Setting up the environment"
        },
        {
            "location": "/#creating-a-database-in-zeesql",
            "text": "The very first step when working with  zeeSQL  it is to create a new database.  The database can be created with a single command.  127.0.0.1:6379> ZEESQL.CREATE_DB DB\n1) 1) \"OK\"  This command will create a new database, and it will associate it with the Redis key  DB .  Any time we want to interact with this database, we will pass  DB  to the  zeeSQL  commands.  It is possible to create more than one database, you can create as many as you like, since they are very lightweight.",
            "title": "Creating a database in zeeSQL"
        },
        {
            "location": "/#sending-commands-to-the-database",
            "text": "After creating a database, we want to interact with it. It is possible to interact with the database sending it commands.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select 1;' NO_HEADER\n1) 1) \"RESULT\"\n2) 1) (integer) 1  We have successfully sent our first command to  zeeSQL  and get our first  RESULT , the integer 1.",
            "title": "Sending commands to the database"
        },
        {
            "location": "/#modify-the-database-structure",
            "text": "A database without tables is not very useful.\nWe will now create a table to store information about users.  In the table we want to store the username, its score and the user email.\nThe username and the email will be text fields, while the score will be an integer field.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'CREATE TABLE users(username TEXT, score INT, email TEXT);'\n1) 1) \"DONE\"\n2) 1) (integer) 0  The operation was successfully and 0 rows have been modified.  However, we now have a table where we can store information about the user.",
            "title": "Modify the database structure"
        },
        {
            "location": "/#add-data-to-the-database",
            "text": "We can now start to add users to our table.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'INSERT INTO users VALUES(\"jsmith\", 3, \"jon.smith@gmail.com\");'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'INSERT INTO users VALUES(\"EvelineInArgentina\", 3, \"eve.frank@yahoo.com\");'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'INSERT INTO users VALUES(\"DuffyAlone\", 12, \"mr.duffy@proton.com\");'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'INSERT INTO users VALUES(\"far\", 6, \"farrington@nv.ru\");'\n1) 1) \"DONE\"\n2) 1) (integer) 1  Each insert was successful and each one added one more row to the database.",
            "title": "Add data to the database"
        },
        {
            "location": "/#query-the-database",
            "text": "After having added data to the database, we want to query those data back.  We can ask for the score of the user  jsmith  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'SELECT score FROM users WHERE username = \"jsmith\"'\n1) 1) \"RESULT\"\n2) 1) \"score\"\n3) 1) \"INT\"\n4) 1) (integer) 3  In this case the score is an integer, and it is of value 3.  Or to know what users have a score greater than 5  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'SELECT username FROM users WHERE score > 5'\n1) 1) \"RESULT\"\n2) 1) \"username\"\n3) 1) \"TEXT\"\n4) 1) \"DuffyAlone\"\n5) 1) \"far\"  In this other case the usernames are of type TEXT and are:  DuffyAlone  and  far .  Since we are not modifying the database, instead of EXECUTING a command with  EXEC  we can just QUERY.  127.0.0.1:6379> ZEESQL.QUERY DB COMMAND 'SELECT username FROM users WHERE score > 5'\n1) 1) \"RESULT\"\n2) 1) \"username\"\n3) 1) \"TEXT\"\n4) 1) \"DuffyAlone\"\n5) 1) \"far\"  QUERY  does not work when trying to modify the database.  127.0.0.1:6379> ZEESQL.QUERY DB COMMAND 'INSERT INTO users VALUES(\"far\", 6, \"farrington@nv.ru\");'\n(error) Statement is not read only but it may modify the database, use `EXEC_STATEMENT` instead.",
            "title": "Query the database"
        },
        {
            "location": "/#modify-the-data",
            "text": "Our users, keep using our platform, are increasing their score. We can increase the score with an update.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'UPDATE users SET score = score + 1 WHERE username = \"jsmith\";'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.QUERY DB COMMAND 'SELECT score FROM users WHERE username = \"jsmith\"'\n1) 1) \"RESULT\"\n2) 1) \"score\"\n3) 1) \"INT\"\n4) 1) (integer) 4  In this example, we first increase the score of the user  jsmith  of one, and then we query the same score.",
            "title": "Modify the data"
        },
        {
            "location": "/#delete-the-data",
            "text": "Eventually our user will leave the platform, in this case we can delete them.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'DELETE FROM users WHERE username = \"far\";'\n1) 1) \"DONE\"\n2) 1) (integer) 1",
            "title": "Delete the data"
        },
        {
            "location": "/#use-arguments-for-your-queries",
            "text": "Up to now, we send only SQL queries that contains all the parameters. \nIt is also possible to send a query with placeholders followed by arguments.\nThis is useful to avoid SQL injections attacks and to avoid string constructions at runtime.  In our example we can increment the score of a player by a specific amount.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'UPDATE users SET score = score + ?2 WHERE username = ?1;' ARGS jsmith 3\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.QUERY DB COMMAND 'SELECT score FROM users WHERE username = ?1' ARGS jsmith\n1) 1) \"RESULT\"\n2) 1) \"score\"\n3) 1) \"INT\"\n4) 1) (integer) 7  The first argument is  ?1  (not  ?0 ) and the second argument is  ?2 .",
            "title": "Use arguments for your queries"
        },
        {
            "location": "/#using-secondary-indexes-or-search-by-values-in-redis",
            "text": "Now that we have understood how to deal with standard zeeSQL databases and how to query them, we can move forward.  Now we will introduce zeeSQL secondary indexes, or how to search and project Redis  hash  data.  In Redis, it is common to store values as hash.\nEach hash is univocally identify by a key, and it has one of more field. \nEach field has a value associated with.  Redis already provide fast access to elements by their key.\nBut it is not possible to search keys from their values.  With zeeSQL we can solve this problem, but automatically push the hashes keys and values to a specific table.  We will work with a simple telemetric system.\nWe have different sensors, each sensor send a timestamp, a temperature value and a humidity value.",
            "title": "Using secondary indexes (or search by values) in Redis"
        },
        {
            "location": "/#saving-the-data-into-redis",
            "text": "As first step let's see how we model the data in raw Redis, using Redis Hashes.  127.0.0.1:6379> HMSET sensor:001:1612733809 timestamp 1612733809 sensor 1 temperature 23 humidity 56\nOK\n127.0.0.1:6379> HMSET sensor:001:1612633809 timestamp 1612633809 sensor 1 temperature 18 humidity 21\nOK\n127.0.0.1:6379> HMSET sensor:001:1612633819 timestamp 1612633819 sensor 1 temperature 20 humidity 23\nOK\n127.0.0.1:6379> HMSET sensor:002:1612733809 timestamp 1612733809 sensor 2 temperature 32 humidity 11\nOK\n127.0.0.1:6379> HMSET sensor:002:1612633809 timestamp 1612633809 sensor 2 temperature 21 humidity 16\nOK\n127.0.0.1:6379> HMSET sensor:002:1612633819 timestamp 1612633819 sensor 2 temperature 23 humidity 12\nOK  The key is in the form  sensor:$sendor_id:$timestamp  and the other fields contains the telemetries' data.",
            "title": "Saving the data into Redis"
        },
        {
            "location": "/#creating-an-index",
            "text": "We now want to store the information in the sensor in an SQL table, for easier access.  127.0.0.1:6379> ZEESQL.INDEX DB NEW TABLE sensors PREFIX sensor:* SCHEMA timestamp INT sensor INT temperature INT humidity INT\nOK  The command creates a new secondary index associate with the table  sensors .\nThe index will be concerned only for the hashes which key start with the prefix  sensor:  ( *  being a catch-all).\nThe schema used by the index will have 4 rows, each of them will be an INTEGER, and the name of those columns are respectively  timestamp .  sensor ,  temperature  and  humidity .  The creation of an index, imply the creation of the table in the database.\nIf the table already exists, it is assumed to contain the correct columns.",
            "title": "Creating an index"
        },
        {
            "location": "/#reading-data-from-the-index",
            "text": "As soon as the index is created, the Redis keys space is scanned and the hashes are added to the table.\nWhich means that we can immediately query the table.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select * from sensors;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"timestamp\"\n   3) \"sensor\"\n   4) \"temperature\"\n   5) \"humidity\"\n3) 1) \"TEXT\"\n   2) \"INT\"\n   3) \"INT\"\n   4) \"INT\"\n   5) \"INT\"\n4) 1) \"sensor:001:1612633809\"\n   2) (integer) 1612633809\n   3) (integer) 1\n   4) (integer) 18\n   5) (integer) 21\n5) 1) \"sensor:002:1612733809\"\n   2) (integer) 1612733809\n   3) (integer) 2\n   4) (integer) 32\n   5) (integer) 11\n6) 1) \"sensor:001:1612733809\"\n   2) (integer) 1612733809\n   3) (integer) 1\n   4) (integer) 23\n   5) (integer) 56\n7) 1) \"sensor:002:1612633819\"\n   2) (integer) 1612633819\n   3) (integer) 2\n   4) (integer) 23\n   5) (integer) 12\n8) 1) \"sensor:002:1612633809\"\n   2) (integer) 1612633809\n   3) (integer) 2\n   4) (integer) 21\n   5) (integer) 16\n9) 1) \"sensor:001:1612633819\"\n   2) (integer) 1612633819\n   3) (integer) 1\n   4) (integer) 20\n   5) (integer) 23",
            "title": "Reading data from the index"
        },
        {
            "location": "/#modify-the-table-of-the-index",
            "text": "It is possible to add, remove and update values to the index table manually.\nDo not do that,  the data between Redis and zeeSQL will go out of sync.",
            "title": "Modify the table of the index"
        },
        {
            "location": "/#adding-hashes",
            "text": "The index continuously listens to the HASH commands of Redis and keeps the table in sync.  127.0.0.1:6379> HMSET sensor:003:1612633819 timestamp 1612633819 sensor 3 temperature 50 humidity 8\nOK\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select * from sensors where sensor = 3;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"timestamp\"\n   3) \"sensor\"\n   4) \"temperature\"\n   5) \"humidity\"\n3) 1) \"TEXT\"\n   2) \"INT\"\n   3) \"INT\"\n   4) \"INT\"\n   5) \"INT\"\n4) 1) \"sensor:003:1612633819\"\n   2) (integer) 1612633819\n   3) (integer) 3\n   4) (integer) 50\n   5) (integer) 8  In this example we added the sensor with ID 3, after the secondary index was already in place.",
            "title": "Adding hashes"
        },
        {
            "location": "/#removing-hashes",
            "text": "Similarly, if a hash is deleted, the correct row is deleted from the table.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select key from sensors where sensor = 2;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n3) 1) \"TEXT\"\n4) 1) \"sensor:002:1612733809\"\n5) 1) \"sensor:002:1612633819\"\n6) 1) \"sensor:002:1612633809\"\n127.0.0.1:6379> DEL sensor:002:1612633809\n(integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select key from sensors where sensor = 2;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n3) 1) \"TEXT\"\n4) 1) \"sensor:002:1612733809\"\n5) 1) \"sensor:002:1612633819\"  As you can see we delete a hash, and the correct row was deleted also from the table.",
            "title": "Removing hashes"
        },
        {
            "location": "/#updating-hashes",
            "text": "As with deletion, updating a hash is also reflected on the index table.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select key, temperature from sensors where sensor = 3;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"temperature\"\n3) 1) \"TEXT\"\n   2) \"INT\"\n4) 1) \"sensor:003:1612633819\"\n   2) (integer) 50\n127.0.0.1:6379> HINCRBY sensor:003:1612633819 temperature 33\n(integer) 83\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select key, temperature from sensors where sensor = 3;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"temperature\"\n3) 1) \"TEXT\"\n   2) \"INT\"\n4) 1) \"sensor:003:1612633819\"\n   2) (integer) 83  In this case we update a hash, and also the table was updated.",
            "title": "Updating hashes"
        },
        {
            "location": "/#querying-the-secondary-index-table",
            "text": "The secondary index table, it is just a plain SQL table.\nzeeSQL does not add any index on the table.\nUser is free to add the SQL indexes it desired to the secondary index table.  Without any index, each query will go through a full table scan.",
            "title": "Querying the secondary index table"
        },
        {
            "location": "/#end",
            "text": "I hope that this tutorial was helpful :)  If you have any question, feel free to contact me simone@redbeardlab.com or on github:  RedBeardLab/zeeSQL-doc",
            "title": "End"
        },
        {
            "location": "/tutorial/",
            "text": "Tutorial for zeeSQL\n\n\nSetting up the environment\n\n\nIf you want to start exploring zeeSQL, this tutorial will walk you through the most important commands to know and how to use them.\n\n\nThe simplest way to follow this tutorial is to launch an instance of \nzeeSQL\n using docker.\n\n\ndocker run --name zeesql --rm -d redbeardlab/zeesql\n\n\n\n\nThe next thing you will need to follow the tutorial is the \nredis-cli\n.\n\n\nYou can connect to the same docker container and start the \nredis-cli\n with:\n\n\ndocker exec -it zeesql redis-cli\n\n\n\n\nAt this point you are inside the \nredis-cli\n, ready to interact with \nRedis\n and \nzeeSQL\n.\n\n\nCreating a database in zeeSQL\n\n\nThe very first step when working with \nzeeSQL\n it is to create a new database.\n\n\nThe database can be created with a single command.\n\n\n127.0.0.1:6379> ZEESQL.CREATE_DB DB\n1) 1) \"OK\"\n\n\n\n\nThis command will create a new database, and it will associate it with the Redis key \nDB\n.\n\n\nAny time we want to interact with this database, we will pass \nDB\n to the \nzeeSQL\n commands.\n\n\nIt is possible to create more than one database, you can create as many as you like, since they are very lightweight.\n\n\nSending commands to the database\n\n\nAfter creating a database, we want to interact with it. It is possible to interact with the database sending it commands.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select 1;' NO_HEADER\n1) 1) \"RESULT\"\n2) 1) (integer) 1\n\n\n\n\nWe have successfully sent our first command to \nzeeSQL\n and get our first \nRESULT\n, the integer 1.\n\n\nModify the database structure\n\n\nA database without tables is not very useful.\nWe will now create a table to store information about users.\n\n\nIn the table we want to store the username, its score and the user email.\nThe username and the email will be text fields, while the score will be an integer field.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'CREATE TABLE users(username TEXT, score INT, email TEXT);'\n1) 1) \"DONE\"\n2) 1) (integer) 0\n\n\n\n\nThe operation was successfully and 0 rows have been modified.\n\n\nHowever, we now have a table where we can store information about the user.\n\n\nAdd data to the database\n\n\nWe can now start to add users to our table.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'INSERT INTO users VALUES(\"jsmith\", 3, \"jon.smith@gmail.com\");'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'INSERT INTO users VALUES(\"EvelineInArgentina\", 3, \"eve.frank@yahoo.com\");'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'INSERT INTO users VALUES(\"DuffyAlone\", 12, \"mr.duffy@proton.com\");'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'INSERT INTO users VALUES(\"far\", 6, \"farrington@nv.ru\");'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n\n\n\n\nEach insert was successful and each one added one more row to the database.\n\n\nQuery the database\n\n\nAfter having added data to the database, we want to query those data back.\n\n\nWe can ask for the score of the user \njsmith\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'SELECT score FROM users WHERE username = \"jsmith\"'\n1) 1) \"RESULT\"\n2) 1) \"score\"\n3) 1) \"INT\"\n4) 1) (integer) 3\n\n\n\n\nIn this case the score is an integer, and it is of value 3.\n\n\nOr to know what users have a score greater than 5\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'SELECT username FROM users WHERE score > 5'\n1) 1) \"RESULT\"\n2) 1) \"username\"\n3) 1) \"TEXT\"\n4) 1) \"DuffyAlone\"\n5) 1) \"far\"\n\n\n\n\nIn this other case the usernames are of type TEXT and are: \nDuffyAlone\n and \nfar\n.\n\n\nSince we are not modifying the database, instead of EXECUTING a command with \nEXEC\n we can just QUERY.\n\n\n127.0.0.1:6379> ZEESQL.QUERY DB COMMAND 'SELECT username FROM users WHERE score > 5'\n1) 1) \"RESULT\"\n2) 1) \"username\"\n3) 1) \"TEXT\"\n4) 1) \"DuffyAlone\"\n5) 1) \"far\"\n\n\n\n\nQUERY\n does not work when trying to modify the database.\n\n\n127.0.0.1:6379> ZEESQL.QUERY DB COMMAND 'INSERT INTO users VALUES(\"far\", 6, \"farrington@nv.ru\");'\n(error) Statement is not read only but it may modify the database, use `EXEC_STATEMENT` instead.\n\n\n\n\nModify the data\n\n\nOur users, keep using our platform, are increasing their score. We can increase the score with an update.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'UPDATE users SET score = score + 1 WHERE username = \"jsmith\";'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.QUERY DB COMMAND 'SELECT score FROM users WHERE username = \"jsmith\"'\n1) 1) \"RESULT\"\n2) 1) \"score\"\n3) 1) \"INT\"\n4) 1) (integer) 4\n\n\n\n\nIn this example, we first increase the score of the user \njsmith\n of one, and then we query the same score.\n\n\nDelete the data\n\n\nEventually our user will leave the platform, in this case we can delete them.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'DELETE FROM users WHERE username = \"far\";'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n\n\n\n\nUse arguments for your queries\n\n\nUp to now, we send only SQL queries that contains all the parameters. \nIt is also possible to send a query with placeholders followed by arguments.\nThis is useful to avoid SQL injections attacks and to avoid string constructions at runtime.\n\n\nIn our example we can increment the score of a player by a specific amount.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'UPDATE users SET score = score + ?2 WHERE username = ?1;' ARGS jsmith 3\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.QUERY DB COMMAND 'SELECT score FROM users WHERE username = ?1' ARGS jsmith\n1) 1) \"RESULT\"\n2) 1) \"score\"\n3) 1) \"INT\"\n4) 1) (integer) 7\n\n\n\n\nThe first argument is \n?1\n (not \n?0\n) and the second argument is \n?2\n.\n\n\nUsing secondary indexes (or search by values) in Redis\n\n\nNow that we have understood how to deal with standard zeeSQL databases and how to query them, we can move forward.\n\n\nNow we will introduce zeeSQL secondary indexes, or how to search and project Redis \nhash\n data.\n\n\nIn Redis, it is common to store values as hash.\nEach hash is univocally identify by a key, and it has one of more field. \nEach field has a value associated with.\n\n\nRedis already provide fast access to elements by their key.\nBut it is not possible to search keys from their values.\n\n\nWith zeeSQL we can solve this problem, but automatically push the hashes keys and values to a specific table.\n\n\nWe will work with a simple telemetric system.\nWe have different sensors, each sensor send a timestamp, a temperature value and a humidity value.\n\n\nSaving the data into Redis\n\n\nAs first step let's see how we model the data in raw Redis, using Redis Hashes.\n\n\n127.0.0.1:6379> HMSET sensor:001:1612733809 timestamp 1612733809 sensor 1 temperature 23 humidity 56\nOK\n127.0.0.1:6379> HMSET sensor:001:1612633809 timestamp 1612633809 sensor 1 temperature 18 humidity 21\nOK\n127.0.0.1:6379> HMSET sensor:001:1612633819 timestamp 1612633819 sensor 1 temperature 20 humidity 23\nOK\n127.0.0.1:6379> HMSET sensor:002:1612733809 timestamp 1612733809 sensor 2 temperature 32 humidity 11\nOK\n127.0.0.1:6379> HMSET sensor:002:1612633809 timestamp 1612633809 sensor 2 temperature 21 humidity 16\nOK\n127.0.0.1:6379> HMSET sensor:002:1612633819 timestamp 1612633819 sensor 2 temperature 23 humidity 12\nOK\n\n\n\n\nThe key is in the form \nsensor:$sendor_id:$timestamp\n and the other fields contains the telemetries' data.\n\n\nCreating an index\n\n\nWe now want to store the information in the sensor in an SQL table, for easier access.\n\n\n127.0.0.1:6379> ZEESQL.INDEX DB NEW TABLE sensors PREFIX sensor:* SCHEMA timestamp INT sensor INT temperature INT humidity INT\nOK\n\n\n\n\nThe command creates a new secondary index associate with the table \nsensors\n.\nThe index will be concerned only for the hashes which key start with the prefix \nsensor:\n (\n*\n being a catch-all).\nThe schema used by the index will have 4 rows, each of them will be an INTEGER, and the name of those columns are respectively \ntimestamp\n. \nsensor\n, \ntemperature\n and \nhumidity\n.\n\n\nThe creation of an index, imply the creation of the table in the database.\nIf the table already exists, it is assumed to contain the correct columns.\n\n\nReading data from the index\n\n\nAs soon as the index is created, the Redis keys space is scanned and the hashes are added to the table.\nWhich means that we can immediately query the table.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select * from sensors;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"timestamp\"\n   3) \"sensor\"\n   4) \"temperature\"\n   5) \"humidity\"\n3) 1) \"TEXT\"\n   2) \"INT\"\n   3) \"INT\"\n   4) \"INT\"\n   5) \"INT\"\n4) 1) \"sensor:001:1612633809\"\n   2) (integer) 1612633809\n   3) (integer) 1\n   4) (integer) 18\n   5) (integer) 21\n5) 1) \"sensor:002:1612733809\"\n   2) (integer) 1612733809\n   3) (integer) 2\n   4) (integer) 32\n   5) (integer) 11\n6) 1) \"sensor:001:1612733809\"\n   2) (integer) 1612733809\n   3) (integer) 1\n   4) (integer) 23\n   5) (integer) 56\n7) 1) \"sensor:002:1612633819\"\n   2) (integer) 1612633819\n   3) (integer) 2\n   4) (integer) 23\n   5) (integer) 12\n8) 1) \"sensor:002:1612633809\"\n   2) (integer) 1612633809\n   3) (integer) 2\n   4) (integer) 21\n   5) (integer) 16\n9) 1) \"sensor:001:1612633819\"\n   2) (integer) 1612633819\n   3) (integer) 1\n   4) (integer) 20\n   5) (integer) 23\n\n\n\n\nModify the table of the index\n\n\nIt is possible to add, remove and update values to the index table manually.\nDo not do that,  the data between Redis and zeeSQL will go out of sync.\n\n\nAdding hashes\n\n\nThe index continuously listens to the HASH commands of Redis and keeps the table in sync.\n\n\n127.0.0.1:6379> HMSET sensor:003:1612633819 timestamp 1612633819 sensor 3 temperature 50 humidity 8\nOK\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select * from sensors where sensor = 3;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"timestamp\"\n   3) \"sensor\"\n   4) \"temperature\"\n   5) \"humidity\"\n3) 1) \"TEXT\"\n   2) \"INT\"\n   3) \"INT\"\n   4) \"INT\"\n   5) \"INT\"\n4) 1) \"sensor:003:1612633819\"\n   2) (integer) 1612633819\n   3) (integer) 3\n   4) (integer) 50\n   5) (integer) 8\n\n\n\n\nIn this example we added the sensor with ID 3, after the secondary index was already in place.\n\n\nRemoving hashes\n\n\nSimilarly, if a hash is deleted, the correct row is deleted from the table.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select key from sensors where sensor = 2;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n3) 1) \"TEXT\"\n4) 1) \"sensor:002:1612733809\"\n5) 1) \"sensor:002:1612633819\"\n6) 1) \"sensor:002:1612633809\"\n127.0.0.1:6379> DEL sensor:002:1612633809\n(integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select key from sensors where sensor = 2;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n3) 1) \"TEXT\"\n4) 1) \"sensor:002:1612733809\"\n5) 1) \"sensor:002:1612633819\"\n\n\n\n\nAs you can see we delete a hash, and the correct row was deleted also from the table.\n\n\nUpdating hashes\n\n\nAs with deletion, updating a hash is also reflected on the index table.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select key, temperature from sensors where sensor = 3;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"temperature\"\n3) 1) \"TEXT\"\n   2) \"INT\"\n4) 1) \"sensor:003:1612633819\"\n   2) (integer) 50\n127.0.0.1:6379> HINCRBY sensor:003:1612633819 temperature 33\n(integer) 83\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select key, temperature from sensors where sensor = 3;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"temperature\"\n3) 1) \"TEXT\"\n   2) \"INT\"\n4) 1) \"sensor:003:1612633819\"\n   2) (integer) 83\n\n\n\n\nIn this case we update a hash, and also the table was updated.\n\n\nQuerying the secondary index table\n\n\nThe secondary index table, it is just a plain SQL table.\nzeeSQL does not add any index on the table.\nUser is free to add the SQL indexes it desired to the secondary index table.\n\n\nWithout any index, each query will go through a full table scan.\n\n\nEnd\n\n\nI hope that this tutorial was helpful :)\n\n\nIf you have any question, feel free to contact me simone@redbeardlab.com or on github: \nRedBeardLab/zeeSQL-doc",
            "title": "Tutorial"
        },
        {
            "location": "/tutorial/#tutorial-for-zeesql",
            "text": "",
            "title": "Tutorial for zeeSQL"
        },
        {
            "location": "/tutorial/#setting-up-the-environment",
            "text": "If you want to start exploring zeeSQL, this tutorial will walk you through the most important commands to know and how to use them.  The simplest way to follow this tutorial is to launch an instance of  zeeSQL  using docker.  docker run --name zeesql --rm -d redbeardlab/zeesql  The next thing you will need to follow the tutorial is the  redis-cli .  You can connect to the same docker container and start the  redis-cli  with:  docker exec -it zeesql redis-cli  At this point you are inside the  redis-cli , ready to interact with  Redis  and  zeeSQL .",
            "title": "Setting up the environment"
        },
        {
            "location": "/tutorial/#creating-a-database-in-zeesql",
            "text": "The very first step when working with  zeeSQL  it is to create a new database.  The database can be created with a single command.  127.0.0.1:6379> ZEESQL.CREATE_DB DB\n1) 1) \"OK\"  This command will create a new database, and it will associate it with the Redis key  DB .  Any time we want to interact with this database, we will pass  DB  to the  zeeSQL  commands.  It is possible to create more than one database, you can create as many as you like, since they are very lightweight.",
            "title": "Creating a database in zeeSQL"
        },
        {
            "location": "/tutorial/#sending-commands-to-the-database",
            "text": "After creating a database, we want to interact with it. It is possible to interact with the database sending it commands.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select 1;' NO_HEADER\n1) 1) \"RESULT\"\n2) 1) (integer) 1  We have successfully sent our first command to  zeeSQL  and get our first  RESULT , the integer 1.",
            "title": "Sending commands to the database"
        },
        {
            "location": "/tutorial/#modify-the-database-structure",
            "text": "A database without tables is not very useful.\nWe will now create a table to store information about users.  In the table we want to store the username, its score and the user email.\nThe username and the email will be text fields, while the score will be an integer field.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'CREATE TABLE users(username TEXT, score INT, email TEXT);'\n1) 1) \"DONE\"\n2) 1) (integer) 0  The operation was successfully and 0 rows have been modified.  However, we now have a table where we can store information about the user.",
            "title": "Modify the database structure"
        },
        {
            "location": "/tutorial/#add-data-to-the-database",
            "text": "We can now start to add users to our table.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'INSERT INTO users VALUES(\"jsmith\", 3, \"jon.smith@gmail.com\");'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'INSERT INTO users VALUES(\"EvelineInArgentina\", 3, \"eve.frank@yahoo.com\");'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'INSERT INTO users VALUES(\"DuffyAlone\", 12, \"mr.duffy@proton.com\");'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'INSERT INTO users VALUES(\"far\", 6, \"farrington@nv.ru\");'\n1) 1) \"DONE\"\n2) 1) (integer) 1  Each insert was successful and each one added one more row to the database.",
            "title": "Add data to the database"
        },
        {
            "location": "/tutorial/#query-the-database",
            "text": "After having added data to the database, we want to query those data back.  We can ask for the score of the user  jsmith  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'SELECT score FROM users WHERE username = \"jsmith\"'\n1) 1) \"RESULT\"\n2) 1) \"score\"\n3) 1) \"INT\"\n4) 1) (integer) 3  In this case the score is an integer, and it is of value 3.  Or to know what users have a score greater than 5  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'SELECT username FROM users WHERE score > 5'\n1) 1) \"RESULT\"\n2) 1) \"username\"\n3) 1) \"TEXT\"\n4) 1) \"DuffyAlone\"\n5) 1) \"far\"  In this other case the usernames are of type TEXT and are:  DuffyAlone  and  far .  Since we are not modifying the database, instead of EXECUTING a command with  EXEC  we can just QUERY.  127.0.0.1:6379> ZEESQL.QUERY DB COMMAND 'SELECT username FROM users WHERE score > 5'\n1) 1) \"RESULT\"\n2) 1) \"username\"\n3) 1) \"TEXT\"\n4) 1) \"DuffyAlone\"\n5) 1) \"far\"  QUERY  does not work when trying to modify the database.  127.0.0.1:6379> ZEESQL.QUERY DB COMMAND 'INSERT INTO users VALUES(\"far\", 6, \"farrington@nv.ru\");'\n(error) Statement is not read only but it may modify the database, use `EXEC_STATEMENT` instead.",
            "title": "Query the database"
        },
        {
            "location": "/tutorial/#modify-the-data",
            "text": "Our users, keep using our platform, are increasing their score. We can increase the score with an update.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'UPDATE users SET score = score + 1 WHERE username = \"jsmith\";'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.QUERY DB COMMAND 'SELECT score FROM users WHERE username = \"jsmith\"'\n1) 1) \"RESULT\"\n2) 1) \"score\"\n3) 1) \"INT\"\n4) 1) (integer) 4  In this example, we first increase the score of the user  jsmith  of one, and then we query the same score.",
            "title": "Modify the data"
        },
        {
            "location": "/tutorial/#delete-the-data",
            "text": "Eventually our user will leave the platform, in this case we can delete them.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'DELETE FROM users WHERE username = \"far\";'\n1) 1) \"DONE\"\n2) 1) (integer) 1",
            "title": "Delete the data"
        },
        {
            "location": "/tutorial/#use-arguments-for-your-queries",
            "text": "Up to now, we send only SQL queries that contains all the parameters. \nIt is also possible to send a query with placeholders followed by arguments.\nThis is useful to avoid SQL injections attacks and to avoid string constructions at runtime.  In our example we can increment the score of a player by a specific amount.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'UPDATE users SET score = score + ?2 WHERE username = ?1;' ARGS jsmith 3\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.QUERY DB COMMAND 'SELECT score FROM users WHERE username = ?1' ARGS jsmith\n1) 1) \"RESULT\"\n2) 1) \"score\"\n3) 1) \"INT\"\n4) 1) (integer) 7  The first argument is  ?1  (not  ?0 ) and the second argument is  ?2 .",
            "title": "Use arguments for your queries"
        },
        {
            "location": "/tutorial/#using-secondary-indexes-or-search-by-values-in-redis",
            "text": "Now that we have understood how to deal with standard zeeSQL databases and how to query them, we can move forward.  Now we will introduce zeeSQL secondary indexes, or how to search and project Redis  hash  data.  In Redis, it is common to store values as hash.\nEach hash is univocally identify by a key, and it has one of more field. \nEach field has a value associated with.  Redis already provide fast access to elements by their key.\nBut it is not possible to search keys from their values.  With zeeSQL we can solve this problem, but automatically push the hashes keys and values to a specific table.  We will work with a simple telemetric system.\nWe have different sensors, each sensor send a timestamp, a temperature value and a humidity value.",
            "title": "Using secondary indexes (or search by values) in Redis"
        },
        {
            "location": "/tutorial/#saving-the-data-into-redis",
            "text": "As first step let's see how we model the data in raw Redis, using Redis Hashes.  127.0.0.1:6379> HMSET sensor:001:1612733809 timestamp 1612733809 sensor 1 temperature 23 humidity 56\nOK\n127.0.0.1:6379> HMSET sensor:001:1612633809 timestamp 1612633809 sensor 1 temperature 18 humidity 21\nOK\n127.0.0.1:6379> HMSET sensor:001:1612633819 timestamp 1612633819 sensor 1 temperature 20 humidity 23\nOK\n127.0.0.1:6379> HMSET sensor:002:1612733809 timestamp 1612733809 sensor 2 temperature 32 humidity 11\nOK\n127.0.0.1:6379> HMSET sensor:002:1612633809 timestamp 1612633809 sensor 2 temperature 21 humidity 16\nOK\n127.0.0.1:6379> HMSET sensor:002:1612633819 timestamp 1612633819 sensor 2 temperature 23 humidity 12\nOK  The key is in the form  sensor:$sendor_id:$timestamp  and the other fields contains the telemetries' data.",
            "title": "Saving the data into Redis"
        },
        {
            "location": "/tutorial/#creating-an-index",
            "text": "We now want to store the information in the sensor in an SQL table, for easier access.  127.0.0.1:6379> ZEESQL.INDEX DB NEW TABLE sensors PREFIX sensor:* SCHEMA timestamp INT sensor INT temperature INT humidity INT\nOK  The command creates a new secondary index associate with the table  sensors .\nThe index will be concerned only for the hashes which key start with the prefix  sensor:  ( *  being a catch-all).\nThe schema used by the index will have 4 rows, each of them will be an INTEGER, and the name of those columns are respectively  timestamp .  sensor ,  temperature  and  humidity .  The creation of an index, imply the creation of the table in the database.\nIf the table already exists, it is assumed to contain the correct columns.",
            "title": "Creating an index"
        },
        {
            "location": "/tutorial/#reading-data-from-the-index",
            "text": "As soon as the index is created, the Redis keys space is scanned and the hashes are added to the table.\nWhich means that we can immediately query the table.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select * from sensors;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"timestamp\"\n   3) \"sensor\"\n   4) \"temperature\"\n   5) \"humidity\"\n3) 1) \"TEXT\"\n   2) \"INT\"\n   3) \"INT\"\n   4) \"INT\"\n   5) \"INT\"\n4) 1) \"sensor:001:1612633809\"\n   2) (integer) 1612633809\n   3) (integer) 1\n   4) (integer) 18\n   5) (integer) 21\n5) 1) \"sensor:002:1612733809\"\n   2) (integer) 1612733809\n   3) (integer) 2\n   4) (integer) 32\n   5) (integer) 11\n6) 1) \"sensor:001:1612733809\"\n   2) (integer) 1612733809\n   3) (integer) 1\n   4) (integer) 23\n   5) (integer) 56\n7) 1) \"sensor:002:1612633819\"\n   2) (integer) 1612633819\n   3) (integer) 2\n   4) (integer) 23\n   5) (integer) 12\n8) 1) \"sensor:002:1612633809\"\n   2) (integer) 1612633809\n   3) (integer) 2\n   4) (integer) 21\n   5) (integer) 16\n9) 1) \"sensor:001:1612633819\"\n   2) (integer) 1612633819\n   3) (integer) 1\n   4) (integer) 20\n   5) (integer) 23",
            "title": "Reading data from the index"
        },
        {
            "location": "/tutorial/#modify-the-table-of-the-index",
            "text": "It is possible to add, remove and update values to the index table manually.\nDo not do that,  the data between Redis and zeeSQL will go out of sync.",
            "title": "Modify the table of the index"
        },
        {
            "location": "/tutorial/#adding-hashes",
            "text": "The index continuously listens to the HASH commands of Redis and keeps the table in sync.  127.0.0.1:6379> HMSET sensor:003:1612633819 timestamp 1612633819 sensor 3 temperature 50 humidity 8\nOK\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select * from sensors where sensor = 3;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"timestamp\"\n   3) \"sensor\"\n   4) \"temperature\"\n   5) \"humidity\"\n3) 1) \"TEXT\"\n   2) \"INT\"\n   3) \"INT\"\n   4) \"INT\"\n   5) \"INT\"\n4) 1) \"sensor:003:1612633819\"\n   2) (integer) 1612633819\n   3) (integer) 3\n   4) (integer) 50\n   5) (integer) 8  In this example we added the sensor with ID 3, after the secondary index was already in place.",
            "title": "Adding hashes"
        },
        {
            "location": "/tutorial/#removing-hashes",
            "text": "Similarly, if a hash is deleted, the correct row is deleted from the table.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select key from sensors where sensor = 2;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n3) 1) \"TEXT\"\n4) 1) \"sensor:002:1612733809\"\n5) 1) \"sensor:002:1612633819\"\n6) 1) \"sensor:002:1612633809\"\n127.0.0.1:6379> DEL sensor:002:1612633809\n(integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select key from sensors where sensor = 2;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n3) 1) \"TEXT\"\n4) 1) \"sensor:002:1612733809\"\n5) 1) \"sensor:002:1612633819\"  As you can see we delete a hash, and the correct row was deleted also from the table.",
            "title": "Removing hashes"
        },
        {
            "location": "/tutorial/#updating-hashes",
            "text": "As with deletion, updating a hash is also reflected on the index table.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select key, temperature from sensors where sensor = 3;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"temperature\"\n3) 1) \"TEXT\"\n   2) \"INT\"\n4) 1) \"sensor:003:1612633819\"\n   2) (integer) 50\n127.0.0.1:6379> HINCRBY sensor:003:1612633819 temperature 33\n(integer) 83\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select key, temperature from sensors where sensor = 3;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"temperature\"\n3) 1) \"TEXT\"\n   2) \"INT\"\n4) 1) \"sensor:003:1612633819\"\n   2) (integer) 83  In this case we update a hash, and also the table was updated.",
            "title": "Updating hashes"
        },
        {
            "location": "/tutorial/#querying-the-secondary-index-table",
            "text": "The secondary index table, it is just a plain SQL table.\nzeeSQL does not add any index on the table.\nUser is free to add the SQL indexes it desired to the secondary index table.  Without any index, each query will go through a full table scan.",
            "title": "Querying the secondary index table"
        },
        {
            "location": "/tutorial/#end",
            "text": "I hope that this tutorial was helpful :)  If you have any question, feel free to contact me simone@redbeardlab.com or on github:  RedBeardLab/zeeSQL-doc",
            "title": "End"
        }
    ]
}