{
    "docs": [
        {
            "location": "/",
            "text": "Tutorial for zeeSQL\n\n\nSetting up the environment\n\n\nIf you want to start exploring zeeSQL, this tutorial will walk you through the most important commands to know and how to use them.\n\n\nThe simplest way to follow this tutorial is to launch an instance of \nzeeSQL\n using docker.\n\n\ndocker run --name zeesql --rm -d redbeardlab/zeesql\n\n\n\n\nThe next thing you will need to follow the tutorial is the \nredis-cli\n.\n\n\nYou can connect to the same docker container and start the \nredis-cli\n with:\n\n\ndocker exec -it zeesql redis-cli\n\n\n\n\nAt this point you are inside the \nredis-cli\n, ready to interact with \nRedis\n and \nzeeSQL\n.\n\n\nCreating a database in zeeSQL\n\n\nThe very first step when working with \nzeeSQL\n it is to create a new database.\n\n\nThe database can be created with a single command.\n\n\n127.0.0.1:6379> ZEESQL.CREATE_DB DB\n1) 1) \"OK\"\n\n\n\n\nThis command will create a new database, and it will associate it with the Redis key \nDB\n.\n\n\nAny time we want to interact with this database, we will pass \nDB\n to the \nzeeSQL\n commands.\n\n\nIt is possible to create more than one database, you can create as many as you like, since they are very lightweight.\n\n\nSending commands to the database\n\n\nAfter creating a database, we want to interact with it. It is possible to interact with the database sending it commands.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select 1;' NO_HEADER\n1) 1) \"RESULT\"\n2) 1) (integer) 1\n\n\n\n\nWe have successfully sent our first command to \nzeeSQL\n and get our first \nRESULT\n, the integer 1.\n\n\nModify the database structure\n\n\nA database without tables is not very useful.\nWe will now create a table to store information about users.\n\n\nIn the table we want to store the username, its score and the user email.\nThe username and the email will be text fields, while the score will be an integer field.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'CREATE TABLE users(username TEXT, score INT, email TEXT);'\n1) 1) \"DONE\"\n2) 1) (integer) 0\n\n\n\n\nThe operation was successfully and 0 rows have been modified.\n\n\nHowever, we now have a table where we can store information about the user.\n\n\nAdd data to the database\n\n\nWe can now start to add users to our table.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'INSERT INTO users VALUES(\"jsmith\", 3, \"jon.smith@gmail.com\");'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'INSERT INTO users VALUES(\"EvelineInArgentina\", 3, \"eve.frank@yahoo.com\");'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'INSERT INTO users VALUES(\"DuffyAlone\", 12, \"mr.duffy@proton.com\");'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'INSERT INTO users VALUES(\"far\", 6, \"farrington@nv.ru\");'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n\n\n\n\nEach insert was successful and each one added one more row to the database.\n\n\nQuery the database\n\n\nAfter having added data to the database, we want to query those data back.\n\n\nWe can ask for the score of the user \njsmith\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'SELECT score FROM users WHERE username = \"jsmith\"'\n1) 1) \"RESULT\"\n2) 1) \"score\"\n3) 1) \"INT\"\n4) 1) (integer) 3\n\n\n\n\nIn this case the score is an integer, and it is of value 3.\n\n\nOr to know what users have a score greater than 5\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'SELECT username FROM users WHERE score > 5'\n1) 1) \"RESULT\"\n2) 1) \"username\"\n3) 1) \"TEXT\"\n4) 1) \"DuffyAlone\"\n5) 1) \"far\"\n\n\n\n\nIn this other case the usernames are of type TEXT and are: \nDuffyAlone\n and \nfar\n.\n\n\nSince we are not modifying the database, instead of EXECUTING a command with \nEXEC\n we can just QUERY.\n\n\n127.0.0.1:6379> ZEESQL.QUERY DB COMMAND 'SELECT username FROM users WHERE score > 5'\n1) 1) \"RESULT\"\n2) 1) \"username\"\n3) 1) \"TEXT\"\n4) 1) \"DuffyAlone\"\n5) 1) \"far\"\n\n\n\n\nQUERY\n does not work when trying to modify the database.\n\n\n127.0.0.1:6379> ZEESQL.QUERY DB COMMAND 'INSERT INTO users VALUES(\"far\", 6, \"farrington@nv.ru\");'\n(error) Statement is not read only but it may modify the database, use `EXEC_STATEMENT` instead.\n\n\n\n\nModify the data\n\n\nOur users, keep using our platform, are increasing their score. We can increase the score with an update.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'UPDATE users SET score = score + 1 WHERE username = \"jsmith\";'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.QUERY DB COMMAND 'SELECT score FROM users WHERE username = \"jsmith\"'\n1) 1) \"RESULT\"\n2) 1) \"score\"\n3) 1) \"INT\"\n4) 1) (integer) 4\n\n\n\n\nIn this example, we first increase the score of the user \njsmith\n of one, and then we query the same score.\n\n\nDelete the data\n\n\nEventually our user will leave the platform, in this case we can delete them.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'DELETE FROM users WHERE username = \"far\";'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n\n\n\n\nUse arguments for your queries\n\n\nUp to now, we send only SQL queries that contains all the parameters. \nIt is also possible to send a query with placeholders followed by arguments.\nThis is useful to avoid SQL injections attacks and to avoid string constructions at runtime.\n\n\nIn our example we can increment the score of a player by a specific amount.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'UPDATE users SET score = score + ?2 WHERE username = ?1;' ARGS jsmith 3\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.QUERY DB COMMAND 'SELECT score FROM users WHERE username = ?1' ARGS jsmith\n1) 1) \"RESULT\"\n2) 1) \"score\"\n3) 1) \"INT\"\n4) 1) (integer) 7\n\n\n\n\nThe first argument is \n?1\n (not \n?0\n) and the second argument is \n?2\n.\n\n\nUsing secondary indexes (or search by values) in Redis\n\n\nNow that we have understood how to deal with standard zeeSQL databases and how to query them, we can move forward.\n\n\nNow we will introduce zeeSQL secondary indexes, or how to search and project Redis \nhash\n data.\n\n\nIn Redis, it is common to store values as hash.\nEach hash is univocally identify by a key, and it has one of more field. \nEach field has a value associated with.\n\n\nRedis already provide fast access to elements by their key.\nBut it is not possible to search keys from their values.\n\n\nWith zeeSQL we can solve this problem, but automatically push the hashes keys and values to a specific table.\n\n\nWe will work with a simple telemetric system.\nWe have different sensors, each sensor send a timestamp, a temperature value and a humidity value.\n\n\nSaving the data into Redis\n\n\nAs first step let's see how we model the data in raw Redis, using Redis Hashes.\n\n\n127.0.0.1:6379> HMSET sensor:001:1612733809 timestamp 1612733809 sensor 1 temperature 23 humidity 56\nOK\n127.0.0.1:6379> HMSET sensor:001:1612633809 timestamp 1612633809 sensor 1 temperature 18 humidity 21\nOK\n127.0.0.1:6379> HMSET sensor:001:1612633819 timestamp 1612633819 sensor 1 temperature 20 humidity 23\nOK\n127.0.0.1:6379> HMSET sensor:002:1612733809 timestamp 1612733809 sensor 2 temperature 32 humidity 11\nOK\n127.0.0.1:6379> HMSET sensor:002:1612633809 timestamp 1612633809 sensor 2 temperature 21 humidity 16\nOK\n127.0.0.1:6379> HMSET sensor:002:1612633819 timestamp 1612633819 sensor 2 temperature 23 humidity 12\nOK\n\n\n\n\nThe key is in the form \nsensor:$sendor_id:$timestamp\n and the other fields contains the telemetries' data.\n\n\nCreating an index\n\n\nWe now want to store the information in the sensor in an SQL table, for easier access.\n\n\n127.0.0.1:6379> ZEESQL.INDEX DB NEW TABLE sensors PREFIX sensor:* SCHEMA timestamp INT sensor INT temperature INT humidity INT\nOK\n\n\n\n\nThe command creates a new secondary index associate with the table \nsensors\n.\nThe index will be concerned only for the hashes which key start with the prefix \nsensor:\n (\n*\n being a catch-all).\nThe schema used by the index will have 4 rows, each of them will be an INTEGER, and the name of those columns are respectively \ntimestamp\n. \nsensor\n, \ntemperature\n and \nhumidity\n.\n\n\nThe creation of an index, imply the creation of the table in the database.\nIf the table already exists, it is assumed to contain the correct columns.\n\n\nReading data from the index\n\n\nAs soon as the index is created, the Redis keys space is scanned and the hashes are added to the table.\nWhich means that we can immediately query the table.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select * from sensors;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"timestamp\"\n   3) \"sensor\"\n   4) \"temperature\"\n   5) \"humidity\"\n3) 1) \"TEXT\"\n   2) \"INT\"\n   3) \"INT\"\n   4) \"INT\"\n   5) \"INT\"\n4) 1) \"sensor:001:1612633809\"\n   2) (integer) 1612633809\n   3) (integer) 1\n   4) (integer) 18\n   5) (integer) 21\n5) 1) \"sensor:002:1612733809\"\n   2) (integer) 1612733809\n   3) (integer) 2\n   4) (integer) 32\n   5) (integer) 11\n6) 1) \"sensor:001:1612733809\"\n   2) (integer) 1612733809\n   3) (integer) 1\n   4) (integer) 23\n   5) (integer) 56\n7) 1) \"sensor:002:1612633819\"\n   2) (integer) 1612633819\n   3) (integer) 2\n   4) (integer) 23\n   5) (integer) 12\n8) 1) \"sensor:002:1612633809\"\n   2) (integer) 1612633809\n   3) (integer) 2\n   4) (integer) 21\n   5) (integer) 16\n9) 1) \"sensor:001:1612633819\"\n   2) (integer) 1612633819\n   3) (integer) 1\n   4) (integer) 20\n   5) (integer) 23\n\n\n\n\nModify the table of the index\n\n\nIt is possible to add, remove and update values to the index table manually.\nDo not do that,  the data between Redis and zeeSQL will go out of sync.\n\n\nAdding hashes\n\n\nThe index continuously listens to the HASH commands of Redis and keeps the table in sync.\n\n\n127.0.0.1:6379> HMSET sensor:003:1612633819 timestamp 1612633819 sensor 3 temperature 50 humidity 8\nOK\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select * from sensors where sensor = 3;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"timestamp\"\n   3) \"sensor\"\n   4) \"temperature\"\n   5) \"humidity\"\n3) 1) \"TEXT\"\n   2) \"INT\"\n   3) \"INT\"\n   4) \"INT\"\n   5) \"INT\"\n4) 1) \"sensor:003:1612633819\"\n   2) (integer) 1612633819\n   3) (integer) 3\n   4) (integer) 50\n   5) (integer) 8\n\n\n\n\nIn this example we added the sensor with ID 3, after the secondary index was already in place.\n\n\nRemoving hashes\n\n\nSimilarly, if a hash is deleted, the correct row is deleted from the table.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select key from sensors where sensor = 2;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n3) 1) \"TEXT\"\n4) 1) \"sensor:002:1612733809\"\n5) 1) \"sensor:002:1612633819\"\n6) 1) \"sensor:002:1612633809\"\n127.0.0.1:6379> DEL sensor:002:1612633809\n(integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select key from sensors where sensor = 2;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n3) 1) \"TEXT\"\n4) 1) \"sensor:002:1612733809\"\n5) 1) \"sensor:002:1612633819\"\n\n\n\n\nAs you can see we delete a hash, and the correct row was deleted also from the table.\n\n\nUpdating hashes\n\n\nAs with deletion, updating a hash is also reflected on the index table.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select key, temperature from sensors where sensor = 3;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"temperature\"\n3) 1) \"TEXT\"\n   2) \"INT\"\n4) 1) \"sensor:003:1612633819\"\n   2) (integer) 50\n127.0.0.1:6379> HINCRBY sensor:003:1612633819 temperature 33\n(integer) 83\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select key, temperature from sensors where sensor = 3;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"temperature\"\n3) 1) \"TEXT\"\n   2) \"INT\"\n4) 1) \"sensor:003:1612633819\"\n   2) (integer) 83\n\n\n\n\nIn this case we update a hash, and also the table was updated.\n\n\nQuerying the secondary index table\n\n\nThe secondary index table, it is just a plain SQL table.\nzeeSQL does not add any index on the table.\nUser is free to add the SQL indexes it desired to the secondary index table.\n\n\nWithout any index, each query will go through a full table scan.\n\n\nEnd\n\n\nI hope that this tutorial was helpful :)\n\n\nIf you have any question, feel free to contact me simone@redbeardlab.com or on github: \nRedBeardLab/zeeSQL-doc",
            "title": "Overview"
        },
        {
            "location": "/#tutorial-for-zeesql",
            "text": "",
            "title": "Tutorial for zeeSQL"
        },
        {
            "location": "/#setting-up-the-environment",
            "text": "If you want to start exploring zeeSQL, this tutorial will walk you through the most important commands to know and how to use them.  The simplest way to follow this tutorial is to launch an instance of  zeeSQL  using docker.  docker run --name zeesql --rm -d redbeardlab/zeesql  The next thing you will need to follow the tutorial is the  redis-cli .  You can connect to the same docker container and start the  redis-cli  with:  docker exec -it zeesql redis-cli  At this point you are inside the  redis-cli , ready to interact with  Redis  and  zeeSQL .",
            "title": "Setting up the environment"
        },
        {
            "location": "/#creating-a-database-in-zeesql",
            "text": "The very first step when working with  zeeSQL  it is to create a new database.  The database can be created with a single command.  127.0.0.1:6379> ZEESQL.CREATE_DB DB\n1) 1) \"OK\"  This command will create a new database, and it will associate it with the Redis key  DB .  Any time we want to interact with this database, we will pass  DB  to the  zeeSQL  commands.  It is possible to create more than one database, you can create as many as you like, since they are very lightweight.",
            "title": "Creating a database in zeeSQL"
        },
        {
            "location": "/#sending-commands-to-the-database",
            "text": "After creating a database, we want to interact with it. It is possible to interact with the database sending it commands.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select 1;' NO_HEADER\n1) 1) \"RESULT\"\n2) 1) (integer) 1  We have successfully sent our first command to  zeeSQL  and get our first  RESULT , the integer 1.",
            "title": "Sending commands to the database"
        },
        {
            "location": "/#modify-the-database-structure",
            "text": "A database without tables is not very useful.\nWe will now create a table to store information about users.  In the table we want to store the username, its score and the user email.\nThe username and the email will be text fields, while the score will be an integer field.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'CREATE TABLE users(username TEXT, score INT, email TEXT);'\n1) 1) \"DONE\"\n2) 1) (integer) 0  The operation was successfully and 0 rows have been modified.  However, we now have a table where we can store information about the user.",
            "title": "Modify the database structure"
        },
        {
            "location": "/#add-data-to-the-database",
            "text": "We can now start to add users to our table.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'INSERT INTO users VALUES(\"jsmith\", 3, \"jon.smith@gmail.com\");'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'INSERT INTO users VALUES(\"EvelineInArgentina\", 3, \"eve.frank@yahoo.com\");'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'INSERT INTO users VALUES(\"DuffyAlone\", 12, \"mr.duffy@proton.com\");'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'INSERT INTO users VALUES(\"far\", 6, \"farrington@nv.ru\");'\n1) 1) \"DONE\"\n2) 1) (integer) 1  Each insert was successful and each one added one more row to the database.",
            "title": "Add data to the database"
        },
        {
            "location": "/#query-the-database",
            "text": "After having added data to the database, we want to query those data back.  We can ask for the score of the user  jsmith  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'SELECT score FROM users WHERE username = \"jsmith\"'\n1) 1) \"RESULT\"\n2) 1) \"score\"\n3) 1) \"INT\"\n4) 1) (integer) 3  In this case the score is an integer, and it is of value 3.  Or to know what users have a score greater than 5  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'SELECT username FROM users WHERE score > 5'\n1) 1) \"RESULT\"\n2) 1) \"username\"\n3) 1) \"TEXT\"\n4) 1) \"DuffyAlone\"\n5) 1) \"far\"  In this other case the usernames are of type TEXT and are:  DuffyAlone  and  far .  Since we are not modifying the database, instead of EXECUTING a command with  EXEC  we can just QUERY.  127.0.0.1:6379> ZEESQL.QUERY DB COMMAND 'SELECT username FROM users WHERE score > 5'\n1) 1) \"RESULT\"\n2) 1) \"username\"\n3) 1) \"TEXT\"\n4) 1) \"DuffyAlone\"\n5) 1) \"far\"  QUERY  does not work when trying to modify the database.  127.0.0.1:6379> ZEESQL.QUERY DB COMMAND 'INSERT INTO users VALUES(\"far\", 6, \"farrington@nv.ru\");'\n(error) Statement is not read only but it may modify the database, use `EXEC_STATEMENT` instead.",
            "title": "Query the database"
        },
        {
            "location": "/#modify-the-data",
            "text": "Our users, keep using our platform, are increasing their score. We can increase the score with an update.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'UPDATE users SET score = score + 1 WHERE username = \"jsmith\";'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.QUERY DB COMMAND 'SELECT score FROM users WHERE username = \"jsmith\"'\n1) 1) \"RESULT\"\n2) 1) \"score\"\n3) 1) \"INT\"\n4) 1) (integer) 4  In this example, we first increase the score of the user  jsmith  of one, and then we query the same score.",
            "title": "Modify the data"
        },
        {
            "location": "/#delete-the-data",
            "text": "Eventually our user will leave the platform, in this case we can delete them.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'DELETE FROM users WHERE username = \"far\";'\n1) 1) \"DONE\"\n2) 1) (integer) 1",
            "title": "Delete the data"
        },
        {
            "location": "/#use-arguments-for-your-queries",
            "text": "Up to now, we send only SQL queries that contains all the parameters. \nIt is also possible to send a query with placeholders followed by arguments.\nThis is useful to avoid SQL injections attacks and to avoid string constructions at runtime.  In our example we can increment the score of a player by a specific amount.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'UPDATE users SET score = score + ?2 WHERE username = ?1;' ARGS jsmith 3\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.QUERY DB COMMAND 'SELECT score FROM users WHERE username = ?1' ARGS jsmith\n1) 1) \"RESULT\"\n2) 1) \"score\"\n3) 1) \"INT\"\n4) 1) (integer) 7  The first argument is  ?1  (not  ?0 ) and the second argument is  ?2 .",
            "title": "Use arguments for your queries"
        },
        {
            "location": "/#using-secondary-indexes-or-search-by-values-in-redis",
            "text": "Now that we have understood how to deal with standard zeeSQL databases and how to query them, we can move forward.  Now we will introduce zeeSQL secondary indexes, or how to search and project Redis  hash  data.  In Redis, it is common to store values as hash.\nEach hash is univocally identify by a key, and it has one of more field. \nEach field has a value associated with.  Redis already provide fast access to elements by their key.\nBut it is not possible to search keys from their values.  With zeeSQL we can solve this problem, but automatically push the hashes keys and values to a specific table.  We will work with a simple telemetric system.\nWe have different sensors, each sensor send a timestamp, a temperature value and a humidity value.",
            "title": "Using secondary indexes (or search by values) in Redis"
        },
        {
            "location": "/#saving-the-data-into-redis",
            "text": "As first step let's see how we model the data in raw Redis, using Redis Hashes.  127.0.0.1:6379> HMSET sensor:001:1612733809 timestamp 1612733809 sensor 1 temperature 23 humidity 56\nOK\n127.0.0.1:6379> HMSET sensor:001:1612633809 timestamp 1612633809 sensor 1 temperature 18 humidity 21\nOK\n127.0.0.1:6379> HMSET sensor:001:1612633819 timestamp 1612633819 sensor 1 temperature 20 humidity 23\nOK\n127.0.0.1:6379> HMSET sensor:002:1612733809 timestamp 1612733809 sensor 2 temperature 32 humidity 11\nOK\n127.0.0.1:6379> HMSET sensor:002:1612633809 timestamp 1612633809 sensor 2 temperature 21 humidity 16\nOK\n127.0.0.1:6379> HMSET sensor:002:1612633819 timestamp 1612633819 sensor 2 temperature 23 humidity 12\nOK  The key is in the form  sensor:$sendor_id:$timestamp  and the other fields contains the telemetries' data.",
            "title": "Saving the data into Redis"
        },
        {
            "location": "/#creating-an-index",
            "text": "We now want to store the information in the sensor in an SQL table, for easier access.  127.0.0.1:6379> ZEESQL.INDEX DB NEW TABLE sensors PREFIX sensor:* SCHEMA timestamp INT sensor INT temperature INT humidity INT\nOK  The command creates a new secondary index associate with the table  sensors .\nThe index will be concerned only for the hashes which key start with the prefix  sensor:  ( *  being a catch-all).\nThe schema used by the index will have 4 rows, each of them will be an INTEGER, and the name of those columns are respectively  timestamp .  sensor ,  temperature  and  humidity .  The creation of an index, imply the creation of the table in the database.\nIf the table already exists, it is assumed to contain the correct columns.",
            "title": "Creating an index"
        },
        {
            "location": "/#reading-data-from-the-index",
            "text": "As soon as the index is created, the Redis keys space is scanned and the hashes are added to the table.\nWhich means that we can immediately query the table.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select * from sensors;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"timestamp\"\n   3) \"sensor\"\n   4) \"temperature\"\n   5) \"humidity\"\n3) 1) \"TEXT\"\n   2) \"INT\"\n   3) \"INT\"\n   4) \"INT\"\n   5) \"INT\"\n4) 1) \"sensor:001:1612633809\"\n   2) (integer) 1612633809\n   3) (integer) 1\n   4) (integer) 18\n   5) (integer) 21\n5) 1) \"sensor:002:1612733809\"\n   2) (integer) 1612733809\n   3) (integer) 2\n   4) (integer) 32\n   5) (integer) 11\n6) 1) \"sensor:001:1612733809\"\n   2) (integer) 1612733809\n   3) (integer) 1\n   4) (integer) 23\n   5) (integer) 56\n7) 1) \"sensor:002:1612633819\"\n   2) (integer) 1612633819\n   3) (integer) 2\n   4) (integer) 23\n   5) (integer) 12\n8) 1) \"sensor:002:1612633809\"\n   2) (integer) 1612633809\n   3) (integer) 2\n   4) (integer) 21\n   5) (integer) 16\n9) 1) \"sensor:001:1612633819\"\n   2) (integer) 1612633819\n   3) (integer) 1\n   4) (integer) 20\n   5) (integer) 23",
            "title": "Reading data from the index"
        },
        {
            "location": "/#modify-the-table-of-the-index",
            "text": "It is possible to add, remove and update values to the index table manually.\nDo not do that,  the data between Redis and zeeSQL will go out of sync.",
            "title": "Modify the table of the index"
        },
        {
            "location": "/#adding-hashes",
            "text": "The index continuously listens to the HASH commands of Redis and keeps the table in sync.  127.0.0.1:6379> HMSET sensor:003:1612633819 timestamp 1612633819 sensor 3 temperature 50 humidity 8\nOK\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select * from sensors where sensor = 3;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"timestamp\"\n   3) \"sensor\"\n   4) \"temperature\"\n   5) \"humidity\"\n3) 1) \"TEXT\"\n   2) \"INT\"\n   3) \"INT\"\n   4) \"INT\"\n   5) \"INT\"\n4) 1) \"sensor:003:1612633819\"\n   2) (integer) 1612633819\n   3) (integer) 3\n   4) (integer) 50\n   5) (integer) 8  In this example we added the sensor with ID 3, after the secondary index was already in place.",
            "title": "Adding hashes"
        },
        {
            "location": "/#removing-hashes",
            "text": "Similarly, if a hash is deleted, the correct row is deleted from the table.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select key from sensors where sensor = 2;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n3) 1) \"TEXT\"\n4) 1) \"sensor:002:1612733809\"\n5) 1) \"sensor:002:1612633819\"\n6) 1) \"sensor:002:1612633809\"\n127.0.0.1:6379> DEL sensor:002:1612633809\n(integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select key from sensors where sensor = 2;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n3) 1) \"TEXT\"\n4) 1) \"sensor:002:1612733809\"\n5) 1) \"sensor:002:1612633819\"  As you can see we delete a hash, and the correct row was deleted also from the table.",
            "title": "Removing hashes"
        },
        {
            "location": "/#updating-hashes",
            "text": "As with deletion, updating a hash is also reflected on the index table.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select key, temperature from sensors where sensor = 3;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"temperature\"\n3) 1) \"TEXT\"\n   2) \"INT\"\n4) 1) \"sensor:003:1612633819\"\n   2) (integer) 50\n127.0.0.1:6379> HINCRBY sensor:003:1612633819 temperature 33\n(integer) 83\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select key, temperature from sensors where sensor = 3;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"temperature\"\n3) 1) \"TEXT\"\n   2) \"INT\"\n4) 1) \"sensor:003:1612633819\"\n   2) (integer) 83  In this case we update a hash, and also the table was updated.",
            "title": "Updating hashes"
        },
        {
            "location": "/#querying-the-secondary-index-table",
            "text": "The secondary index table, it is just a plain SQL table.\nzeeSQL does not add any index on the table.\nUser is free to add the SQL indexes it desired to the secondary index table.  Without any index, each query will go through a full table scan.",
            "title": "Querying the secondary index table"
        },
        {
            "location": "/#end",
            "text": "I hope that this tutorial was helpful :)  If you have any question, feel free to contact me simone@redbeardlab.com or on github:  RedBeardLab/zeeSQL-doc",
            "title": "End"
        },
        {
            "location": "/tutorial/",
            "text": "Tutorial for zeeSQL\n\n\nSetting up the environment\n\n\nIf you want to start exploring zeeSQL, this tutorial will walk you through the most important commands to know and how to use them.\n\n\nThe simplest way to follow this tutorial is to launch an instance of \nzeeSQL\n using docker.\n\n\ndocker run --name zeesql --rm -d redbeardlab/zeesql\n\n\n\n\nThe next thing you will need to follow the tutorial is the \nredis-cli\n.\n\n\nYou can connect to the same docker container and start the \nredis-cli\n with:\n\n\ndocker exec -it zeesql redis-cli\n\n\n\n\nAt this point you are inside the \nredis-cli\n, ready to interact with \nRedis\n and \nzeeSQL\n.\n\n\nCreating a database in zeeSQL\n\n\nThe very first step when working with \nzeeSQL\n it is to create a new database.\n\n\nThe database can be created with a single command.\n\n\n127.0.0.1:6379> ZEESQL.CREATE_DB DB\n1) 1) \"OK\"\n\n\n\n\nThis command will create a new database, and it will associate it with the Redis key \nDB\n.\n\n\nAny time we want to interact with this database, we will pass \nDB\n to the \nzeeSQL\n commands.\n\n\nIt is possible to create more than one database, you can create as many as you like, since they are very lightweight.\n\n\nSending commands to the database\n\n\nAfter creating a database, we want to interact with it. It is possible to interact with the database sending it commands.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select 1;' NO_HEADER\n1) 1) \"RESULT\"\n2) 1) (integer) 1\n\n\n\n\nWe have successfully sent our first command to \nzeeSQL\n and get our first \nRESULT\n, the integer 1.\n\n\nModify the database structure\n\n\nA database without tables is not very useful.\nWe will now create a table to store information about users.\n\n\nIn the table we want to store the username, its score and the user email.\nThe username and the email will be text fields, while the score will be an integer field.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'CREATE TABLE users(username TEXT, score INT, email TEXT);'\n1) 1) \"DONE\"\n2) 1) (integer) 0\n\n\n\n\nThe operation was successfully and 0 rows have been modified.\n\n\nHowever, we now have a table where we can store information about the user.\n\n\nAdd data to the database\n\n\nWe can now start to add users to our table.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'INSERT INTO users VALUES(\"jsmith\", 3, \"jon.smith@gmail.com\");'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'INSERT INTO users VALUES(\"EvelineInArgentina\", 3, \"eve.frank@yahoo.com\");'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'INSERT INTO users VALUES(\"DuffyAlone\", 12, \"mr.duffy@proton.com\");'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'INSERT INTO users VALUES(\"far\", 6, \"farrington@nv.ru\");'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n\n\n\n\nEach insert was successful and each one added one more row to the database.\n\n\nQuery the database\n\n\nAfter having added data to the database, we want to query those data back.\n\n\nWe can ask for the score of the user \njsmith\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'SELECT score FROM users WHERE username = \"jsmith\"'\n1) 1) \"RESULT\"\n2) 1) \"score\"\n3) 1) \"INT\"\n4) 1) (integer) 3\n\n\n\n\nIn this case the score is an integer, and it is of value 3.\n\n\nOr to know what users have a score greater than 5\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'SELECT username FROM users WHERE score > 5'\n1) 1) \"RESULT\"\n2) 1) \"username\"\n3) 1) \"TEXT\"\n4) 1) \"DuffyAlone\"\n5) 1) \"far\"\n\n\n\n\nIn this other case the usernames are of type TEXT and are: \nDuffyAlone\n and \nfar\n.\n\n\nSince we are not modifying the database, instead of EXECUTING a command with \nEXEC\n we can just QUERY.\n\n\n127.0.0.1:6379> ZEESQL.QUERY DB COMMAND 'SELECT username FROM users WHERE score > 5'\n1) 1) \"RESULT\"\n2) 1) \"username\"\n3) 1) \"TEXT\"\n4) 1) \"DuffyAlone\"\n5) 1) \"far\"\n\n\n\n\nQUERY\n does not work when trying to modify the database.\n\n\n127.0.0.1:6379> ZEESQL.QUERY DB COMMAND 'INSERT INTO users VALUES(\"far\", 6, \"farrington@nv.ru\");'\n(error) Statement is not read only but it may modify the database, use `EXEC_STATEMENT` instead.\n\n\n\n\nModify the data\n\n\nOur users, keep using our platform, are increasing their score. We can increase the score with an update.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'UPDATE users SET score = score + 1 WHERE username = \"jsmith\";'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.QUERY DB COMMAND 'SELECT score FROM users WHERE username = \"jsmith\"'\n1) 1) \"RESULT\"\n2) 1) \"score\"\n3) 1) \"INT\"\n4) 1) (integer) 4\n\n\n\n\nIn this example, we first increase the score of the user \njsmith\n of one, and then we query the same score.\n\n\nDelete the data\n\n\nEventually our user will leave the platform, in this case we can delete them.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'DELETE FROM users WHERE username = \"far\";'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n\n\n\n\nUse arguments for your queries\n\n\nUp to now, we send only SQL queries that contains all the parameters. \nIt is also possible to send a query with placeholders followed by arguments.\nThis is useful to avoid SQL injections attacks and to avoid string constructions at runtime.\n\n\nIn our example we can increment the score of a player by a specific amount.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'UPDATE users SET score = score + ?2 WHERE username = ?1;' ARGS jsmith 3\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.QUERY DB COMMAND 'SELECT score FROM users WHERE username = ?1' ARGS jsmith\n1) 1) \"RESULT\"\n2) 1) \"score\"\n3) 1) \"INT\"\n4) 1) (integer) 7\n\n\n\n\nThe first argument is \n?1\n (not \n?0\n) and the second argument is \n?2\n.\n\n\nUsing secondary indexes (or search by values) in Redis\n\n\nNow that we have understood how to deal with standard zeeSQL databases and how to query them, we can move forward.\n\n\nNow we will introduce zeeSQL secondary indexes, or how to search and project Redis \nhash\n data.\n\n\nIn Redis, it is common to store values as hash.\nEach hash is univocally identify by a key, and it has one of more field. \nEach field has a value associated with.\n\n\nRedis already provide fast access to elements by their key.\nBut it is not possible to search keys from their values.\n\n\nWith zeeSQL we can solve this problem, but automatically push the hashes keys and values to a specific table.\n\n\nWe will work with a simple telemetric system.\nWe have different sensors, each sensor send a timestamp, a temperature value and a humidity value.\n\n\nSaving the data into Redis\n\n\nAs first step let's see how we model the data in raw Redis, using Redis Hashes.\n\n\n127.0.0.1:6379> HMSET sensor:001:1612733809 timestamp 1612733809 sensor 1 temperature 23 humidity 56\nOK\n127.0.0.1:6379> HMSET sensor:001:1612633809 timestamp 1612633809 sensor 1 temperature 18 humidity 21\nOK\n127.0.0.1:6379> HMSET sensor:001:1612633819 timestamp 1612633819 sensor 1 temperature 20 humidity 23\nOK\n127.0.0.1:6379> HMSET sensor:002:1612733809 timestamp 1612733809 sensor 2 temperature 32 humidity 11\nOK\n127.0.0.1:6379> HMSET sensor:002:1612633809 timestamp 1612633809 sensor 2 temperature 21 humidity 16\nOK\n127.0.0.1:6379> HMSET sensor:002:1612633819 timestamp 1612633819 sensor 2 temperature 23 humidity 12\nOK\n\n\n\n\nThe key is in the form \nsensor:$sendor_id:$timestamp\n and the other fields contains the telemetries' data.\n\n\nCreating an index\n\n\nWe now want to store the information in the sensor in an SQL table, for easier access.\n\n\n127.0.0.1:6379> ZEESQL.INDEX DB NEW TABLE sensors PREFIX sensor:* SCHEMA timestamp INT sensor INT temperature INT humidity INT\nOK\n\n\n\n\nThe command creates a new secondary index associate with the table \nsensors\n.\nThe index will be concerned only for the hashes which key start with the prefix \nsensor:\n (\n*\n being a catch-all).\nThe schema used by the index will have 4 rows, each of them will be an INTEGER, and the name of those columns are respectively \ntimestamp\n. \nsensor\n, \ntemperature\n and \nhumidity\n.\n\n\nThe creation of an index, imply the creation of the table in the database.\nIf the table already exists, it is assumed to contain the correct columns.\n\n\nReading data from the index\n\n\nAs soon as the index is created, the Redis keys space is scanned and the hashes are added to the table.\nWhich means that we can immediately query the table.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select * from sensors;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"timestamp\"\n   3) \"sensor\"\n   4) \"temperature\"\n   5) \"humidity\"\n3) 1) \"TEXT\"\n   2) \"INT\"\n   3) \"INT\"\n   4) \"INT\"\n   5) \"INT\"\n4) 1) \"sensor:001:1612633809\"\n   2) (integer) 1612633809\n   3) (integer) 1\n   4) (integer) 18\n   5) (integer) 21\n5) 1) \"sensor:002:1612733809\"\n   2) (integer) 1612733809\n   3) (integer) 2\n   4) (integer) 32\n   5) (integer) 11\n6) 1) \"sensor:001:1612733809\"\n   2) (integer) 1612733809\n   3) (integer) 1\n   4) (integer) 23\n   5) (integer) 56\n7) 1) \"sensor:002:1612633819\"\n   2) (integer) 1612633819\n   3) (integer) 2\n   4) (integer) 23\n   5) (integer) 12\n8) 1) \"sensor:002:1612633809\"\n   2) (integer) 1612633809\n   3) (integer) 2\n   4) (integer) 21\n   5) (integer) 16\n9) 1) \"sensor:001:1612633819\"\n   2) (integer) 1612633819\n   3) (integer) 1\n   4) (integer) 20\n   5) (integer) 23\n\n\n\n\nModify the table of the index\n\n\nIt is possible to add, remove and update values to the index table manually.\nDo not do that,  the data between Redis and zeeSQL will go out of sync.\n\n\nAdding hashes\n\n\nThe index continuously listens to the HASH commands of Redis and keeps the table in sync.\n\n\n127.0.0.1:6379> HMSET sensor:003:1612633819 timestamp 1612633819 sensor 3 temperature 50 humidity 8\nOK\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select * from sensors where sensor = 3;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"timestamp\"\n   3) \"sensor\"\n   4) \"temperature\"\n   5) \"humidity\"\n3) 1) \"TEXT\"\n   2) \"INT\"\n   3) \"INT\"\n   4) \"INT\"\n   5) \"INT\"\n4) 1) \"sensor:003:1612633819\"\n   2) (integer) 1612633819\n   3) (integer) 3\n   4) (integer) 50\n   5) (integer) 8\n\n\n\n\nIn this example we added the sensor with ID 3, after the secondary index was already in place.\n\n\nRemoving hashes\n\n\nSimilarly, if a hash is deleted, the correct row is deleted from the table.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select key from sensors where sensor = 2;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n3) 1) \"TEXT\"\n4) 1) \"sensor:002:1612733809\"\n5) 1) \"sensor:002:1612633819\"\n6) 1) \"sensor:002:1612633809\"\n127.0.0.1:6379> DEL sensor:002:1612633809\n(integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select key from sensors where sensor = 2;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n3) 1) \"TEXT\"\n4) 1) \"sensor:002:1612733809\"\n5) 1) \"sensor:002:1612633819\"\n\n\n\n\nAs you can see we delete a hash, and the correct row was deleted also from the table.\n\n\nUpdating hashes\n\n\nAs with deletion, updating a hash is also reflected on the index table.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select key, temperature from sensors where sensor = 3;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"temperature\"\n3) 1) \"TEXT\"\n   2) \"INT\"\n4) 1) \"sensor:003:1612633819\"\n   2) (integer) 50\n127.0.0.1:6379> HINCRBY sensor:003:1612633819 temperature 33\n(integer) 83\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select key, temperature from sensors where sensor = 3;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"temperature\"\n3) 1) \"TEXT\"\n   2) \"INT\"\n4) 1) \"sensor:003:1612633819\"\n   2) (integer) 83\n\n\n\n\nIn this case we update a hash, and also the table was updated.\n\n\nQuerying the secondary index table\n\n\nThe secondary index table, it is just a plain SQL table.\nzeeSQL does not add any index on the table.\nUser is free to add the SQL indexes it desired to the secondary index table.\n\n\nWithout any index, each query will go through a full table scan.\n\n\nEnd\n\n\nI hope that this tutorial was helpful :)\n\n\nIf you have any question, feel free to contact me simone@redbeardlab.com or on github: \nRedBeardLab/zeeSQL-doc",
            "title": "Tutorial"
        },
        {
            "location": "/tutorial/#tutorial-for-zeesql",
            "text": "",
            "title": "Tutorial for zeeSQL"
        },
        {
            "location": "/tutorial/#setting-up-the-environment",
            "text": "If you want to start exploring zeeSQL, this tutorial will walk you through the most important commands to know and how to use them.  The simplest way to follow this tutorial is to launch an instance of  zeeSQL  using docker.  docker run --name zeesql --rm -d redbeardlab/zeesql  The next thing you will need to follow the tutorial is the  redis-cli .  You can connect to the same docker container and start the  redis-cli  with:  docker exec -it zeesql redis-cli  At this point you are inside the  redis-cli , ready to interact with  Redis  and  zeeSQL .",
            "title": "Setting up the environment"
        },
        {
            "location": "/tutorial/#creating-a-database-in-zeesql",
            "text": "The very first step when working with  zeeSQL  it is to create a new database.  The database can be created with a single command.  127.0.0.1:6379> ZEESQL.CREATE_DB DB\n1) 1) \"OK\"  This command will create a new database, and it will associate it with the Redis key  DB .  Any time we want to interact with this database, we will pass  DB  to the  zeeSQL  commands.  It is possible to create more than one database, you can create as many as you like, since they are very lightweight.",
            "title": "Creating a database in zeeSQL"
        },
        {
            "location": "/tutorial/#sending-commands-to-the-database",
            "text": "After creating a database, we want to interact with it. It is possible to interact with the database sending it commands.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select 1;' NO_HEADER\n1) 1) \"RESULT\"\n2) 1) (integer) 1  We have successfully sent our first command to  zeeSQL  and get our first  RESULT , the integer 1.",
            "title": "Sending commands to the database"
        },
        {
            "location": "/tutorial/#modify-the-database-structure",
            "text": "A database without tables is not very useful.\nWe will now create a table to store information about users.  In the table we want to store the username, its score and the user email.\nThe username and the email will be text fields, while the score will be an integer field.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'CREATE TABLE users(username TEXT, score INT, email TEXT);'\n1) 1) \"DONE\"\n2) 1) (integer) 0  The operation was successfully and 0 rows have been modified.  However, we now have a table where we can store information about the user.",
            "title": "Modify the database structure"
        },
        {
            "location": "/tutorial/#add-data-to-the-database",
            "text": "We can now start to add users to our table.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'INSERT INTO users VALUES(\"jsmith\", 3, \"jon.smith@gmail.com\");'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'INSERT INTO users VALUES(\"EvelineInArgentina\", 3, \"eve.frank@yahoo.com\");'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'INSERT INTO users VALUES(\"DuffyAlone\", 12, \"mr.duffy@proton.com\");'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'INSERT INTO users VALUES(\"far\", 6, \"farrington@nv.ru\");'\n1) 1) \"DONE\"\n2) 1) (integer) 1  Each insert was successful and each one added one more row to the database.",
            "title": "Add data to the database"
        },
        {
            "location": "/tutorial/#query-the-database",
            "text": "After having added data to the database, we want to query those data back.  We can ask for the score of the user  jsmith  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'SELECT score FROM users WHERE username = \"jsmith\"'\n1) 1) \"RESULT\"\n2) 1) \"score\"\n3) 1) \"INT\"\n4) 1) (integer) 3  In this case the score is an integer, and it is of value 3.  Or to know what users have a score greater than 5  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'SELECT username FROM users WHERE score > 5'\n1) 1) \"RESULT\"\n2) 1) \"username\"\n3) 1) \"TEXT\"\n4) 1) \"DuffyAlone\"\n5) 1) \"far\"  In this other case the usernames are of type TEXT and are:  DuffyAlone  and  far .  Since we are not modifying the database, instead of EXECUTING a command with  EXEC  we can just QUERY.  127.0.0.1:6379> ZEESQL.QUERY DB COMMAND 'SELECT username FROM users WHERE score > 5'\n1) 1) \"RESULT\"\n2) 1) \"username\"\n3) 1) \"TEXT\"\n4) 1) \"DuffyAlone\"\n5) 1) \"far\"  QUERY  does not work when trying to modify the database.  127.0.0.1:6379> ZEESQL.QUERY DB COMMAND 'INSERT INTO users VALUES(\"far\", 6, \"farrington@nv.ru\");'\n(error) Statement is not read only but it may modify the database, use `EXEC_STATEMENT` instead.",
            "title": "Query the database"
        },
        {
            "location": "/tutorial/#modify-the-data",
            "text": "Our users, keep using our platform, are increasing their score. We can increase the score with an update.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'UPDATE users SET score = score + 1 WHERE username = \"jsmith\";'\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.QUERY DB COMMAND 'SELECT score FROM users WHERE username = \"jsmith\"'\n1) 1) \"RESULT\"\n2) 1) \"score\"\n3) 1) \"INT\"\n4) 1) (integer) 4  In this example, we first increase the score of the user  jsmith  of one, and then we query the same score.",
            "title": "Modify the data"
        },
        {
            "location": "/tutorial/#delete-the-data",
            "text": "Eventually our user will leave the platform, in this case we can delete them.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'DELETE FROM users WHERE username = \"far\";'\n1) 1) \"DONE\"\n2) 1) (integer) 1",
            "title": "Delete the data"
        },
        {
            "location": "/tutorial/#use-arguments-for-your-queries",
            "text": "Up to now, we send only SQL queries that contains all the parameters. \nIt is also possible to send a query with placeholders followed by arguments.\nThis is useful to avoid SQL injections attacks and to avoid string constructions at runtime.  In our example we can increment the score of a player by a specific amount.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'UPDATE users SET score = score + ?2 WHERE username = ?1;' ARGS jsmith 3\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.QUERY DB COMMAND 'SELECT score FROM users WHERE username = ?1' ARGS jsmith\n1) 1) \"RESULT\"\n2) 1) \"score\"\n3) 1) \"INT\"\n4) 1) (integer) 7  The first argument is  ?1  (not  ?0 ) and the second argument is  ?2 .",
            "title": "Use arguments for your queries"
        },
        {
            "location": "/tutorial/#using-secondary-indexes-or-search-by-values-in-redis",
            "text": "Now that we have understood how to deal with standard zeeSQL databases and how to query them, we can move forward.  Now we will introduce zeeSQL secondary indexes, or how to search and project Redis  hash  data.  In Redis, it is common to store values as hash.\nEach hash is univocally identify by a key, and it has one of more field. \nEach field has a value associated with.  Redis already provide fast access to elements by their key.\nBut it is not possible to search keys from their values.  With zeeSQL we can solve this problem, but automatically push the hashes keys and values to a specific table.  We will work with a simple telemetric system.\nWe have different sensors, each sensor send a timestamp, a temperature value and a humidity value.",
            "title": "Using secondary indexes (or search by values) in Redis"
        },
        {
            "location": "/tutorial/#saving-the-data-into-redis",
            "text": "As first step let's see how we model the data in raw Redis, using Redis Hashes.  127.0.0.1:6379> HMSET sensor:001:1612733809 timestamp 1612733809 sensor 1 temperature 23 humidity 56\nOK\n127.0.0.1:6379> HMSET sensor:001:1612633809 timestamp 1612633809 sensor 1 temperature 18 humidity 21\nOK\n127.0.0.1:6379> HMSET sensor:001:1612633819 timestamp 1612633819 sensor 1 temperature 20 humidity 23\nOK\n127.0.0.1:6379> HMSET sensor:002:1612733809 timestamp 1612733809 sensor 2 temperature 32 humidity 11\nOK\n127.0.0.1:6379> HMSET sensor:002:1612633809 timestamp 1612633809 sensor 2 temperature 21 humidity 16\nOK\n127.0.0.1:6379> HMSET sensor:002:1612633819 timestamp 1612633819 sensor 2 temperature 23 humidity 12\nOK  The key is in the form  sensor:$sendor_id:$timestamp  and the other fields contains the telemetries' data.",
            "title": "Saving the data into Redis"
        },
        {
            "location": "/tutorial/#creating-an-index",
            "text": "We now want to store the information in the sensor in an SQL table, for easier access.  127.0.0.1:6379> ZEESQL.INDEX DB NEW TABLE sensors PREFIX sensor:* SCHEMA timestamp INT sensor INT temperature INT humidity INT\nOK  The command creates a new secondary index associate with the table  sensors .\nThe index will be concerned only for the hashes which key start with the prefix  sensor:  ( *  being a catch-all).\nThe schema used by the index will have 4 rows, each of them will be an INTEGER, and the name of those columns are respectively  timestamp .  sensor ,  temperature  and  humidity .  The creation of an index, imply the creation of the table in the database.\nIf the table already exists, it is assumed to contain the correct columns.",
            "title": "Creating an index"
        },
        {
            "location": "/tutorial/#reading-data-from-the-index",
            "text": "As soon as the index is created, the Redis keys space is scanned and the hashes are added to the table.\nWhich means that we can immediately query the table.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select * from sensors;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"timestamp\"\n   3) \"sensor\"\n   4) \"temperature\"\n   5) \"humidity\"\n3) 1) \"TEXT\"\n   2) \"INT\"\n   3) \"INT\"\n   4) \"INT\"\n   5) \"INT\"\n4) 1) \"sensor:001:1612633809\"\n   2) (integer) 1612633809\n   3) (integer) 1\n   4) (integer) 18\n   5) (integer) 21\n5) 1) \"sensor:002:1612733809\"\n   2) (integer) 1612733809\n   3) (integer) 2\n   4) (integer) 32\n   5) (integer) 11\n6) 1) \"sensor:001:1612733809\"\n   2) (integer) 1612733809\n   3) (integer) 1\n   4) (integer) 23\n   5) (integer) 56\n7) 1) \"sensor:002:1612633819\"\n   2) (integer) 1612633819\n   3) (integer) 2\n   4) (integer) 23\n   5) (integer) 12\n8) 1) \"sensor:002:1612633809\"\n   2) (integer) 1612633809\n   3) (integer) 2\n   4) (integer) 21\n   5) (integer) 16\n9) 1) \"sensor:001:1612633819\"\n   2) (integer) 1612633819\n   3) (integer) 1\n   4) (integer) 20\n   5) (integer) 23",
            "title": "Reading data from the index"
        },
        {
            "location": "/tutorial/#modify-the-table-of-the-index",
            "text": "It is possible to add, remove and update values to the index table manually.\nDo not do that,  the data between Redis and zeeSQL will go out of sync.",
            "title": "Modify the table of the index"
        },
        {
            "location": "/tutorial/#adding-hashes",
            "text": "The index continuously listens to the HASH commands of Redis and keeps the table in sync.  127.0.0.1:6379> HMSET sensor:003:1612633819 timestamp 1612633819 sensor 3 temperature 50 humidity 8\nOK\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select * from sensors where sensor = 3;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"timestamp\"\n   3) \"sensor\"\n   4) \"temperature\"\n   5) \"humidity\"\n3) 1) \"TEXT\"\n   2) \"INT\"\n   3) \"INT\"\n   4) \"INT\"\n   5) \"INT\"\n4) 1) \"sensor:003:1612633819\"\n   2) (integer) 1612633819\n   3) (integer) 3\n   4) (integer) 50\n   5) (integer) 8  In this example we added the sensor with ID 3, after the secondary index was already in place.",
            "title": "Adding hashes"
        },
        {
            "location": "/tutorial/#removing-hashes",
            "text": "Similarly, if a hash is deleted, the correct row is deleted from the table.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select key from sensors where sensor = 2;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n3) 1) \"TEXT\"\n4) 1) \"sensor:002:1612733809\"\n5) 1) \"sensor:002:1612633819\"\n6) 1) \"sensor:002:1612633809\"\n127.0.0.1:6379> DEL sensor:002:1612633809\n(integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select key from sensors where sensor = 2;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n3) 1) \"TEXT\"\n4) 1) \"sensor:002:1612733809\"\n5) 1) \"sensor:002:1612633819\"  As you can see we delete a hash, and the correct row was deleted also from the table.",
            "title": "Removing hashes"
        },
        {
            "location": "/tutorial/#updating-hashes",
            "text": "As with deletion, updating a hash is also reflected on the index table.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select key, temperature from sensors where sensor = 3;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"temperature\"\n3) 1) \"TEXT\"\n   2) \"INT\"\n4) 1) \"sensor:003:1612633819\"\n   2) (integer) 50\n127.0.0.1:6379> HINCRBY sensor:003:1612633819 temperature 33\n(integer) 83\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND 'select key, temperature from sensors where sensor = 3;'\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"temperature\"\n3) 1) \"TEXT\"\n   2) \"INT\"\n4) 1) \"sensor:003:1612633819\"\n   2) (integer) 83  In this case we update a hash, and also the table was updated.",
            "title": "Updating hashes"
        },
        {
            "location": "/tutorial/#querying-the-secondary-index-table",
            "text": "The secondary index table, it is just a plain SQL table.\nzeeSQL does not add any index on the table.\nUser is free to add the SQL indexes it desired to the secondary index table.  Without any index, each query will go through a full table scan.",
            "title": "Querying the secondary index table"
        },
        {
            "location": "/tutorial/#end",
            "text": "I hope that this tutorial was helpful :)  If you have any question, feel free to contact me simone@redbeardlab.com or on github:  RedBeardLab/zeeSQL-doc",
            "title": "End"
        },
        {
            "location": "/references/",
            "text": "References\n\n\nThis document explains all the API that zeeSQL provide to the users.\n\n\nThis document refers to the latest API, but we commit to backward-compatible API.\n\n\nFor each command, it exposes first the name and then the syntax, and finally a brief explanation of what is going on inside the code.\n\n\nWhere is possible, it provides also an estimate of the complexity but since we are talking about databases not all queries have the same time and spatial complexity.\n\n\nFinally, if it is appropriate the document also provides several references to external material that the interested reader can use to understand better the dynamics of every command.\n\n\nZEESQL.CREATE_DB\n\n\nZEESQL.CREATE_DB db_key [PATH path]\n\n\n\n\nThis command creates a new DB and associates it with the key.\n\n\nThe path argument is optional and, if provided is the file that SQLite will use.\nIt can be an existing SQLite file or it can be a not existing file.\n\n\nIf the file exists and if it is a regular SQLite file that database will be used.\nIf the file does not exist a new file will be created.\n\n\nIf the path is not provided it will open an in-memory database. Not providing a path is equivalent to provide the special string \n:memory:\n as the path argument.\n\n\nAfter opening the database it inserts metadata into it and then starts a thread loop.\n\n\nComplexity\n: O(1), it means constant, it does not necessarily mean \nfast\n. However, is fast enough for any use case facing human users (eg create a new database for every user logging into a website.)\n\n\nExamples\n:\n\n\n127.0.0.1:6379> ZEESQL.CREATE_DB DB \n1) 1) \"OK\"\n\n\n\n\nThis command created an in-memory database.\nPersistency is managed by Redis with AOF or RDB following the setting of your Redis instance.\n\n\n127.0.0.1:6379> ZEESQL.CREATE_DB on_disk_db PATH /tmp/foo.sqlite\n1) 1) \"OK\"\n\n\n\n\nThis command created a database that uses a file as storage support, in this case \n/tmp/foo.sqlite\n.\n\n\nIf the file does not exist, it is created.\n\n\nIf the file is already an SQLite database, it gets used immediately with all the data already loaded.\n\n\nIf the file is not an SQLite database, an error is raised.\n\n\nSee also\n: \n\n\n\n\nSQLite \nsqlite3_open_v2\n\n\n\n\nDEL\n\n\nDEL db_key [key ...]\n\n\n\n\nThis command is a generic command from Redis.\n\n\nIt eliminates keys from Redis itself, as well if the key is a RediSQL database create with \nZEESQL.CREATE_DB\n it will eliminate the SQLite database, stop the thread loop and clean up everything left.\n\n\nIf the database is backed by a file the file will be closed, but it won't be deleted.\n\n\nComplexity\n: DEL is O(N) on the number of keys, if you are only eliminating the key associated with the SQLite database will be constant, O(1).\n\n\nExamples\n:\n\n\n127.0.0.1:6379> ZEESQL.CREATE_DB DB \n1) 1) \"OK\"\n127.0.0.1:6379> DEL DB\n(integer) 1\n\n\n\n\nSee also\n: \n\n\n\n\nSQLite \nsqlite3_close\n\n\nRedis \nDEL\n\n\n\n\nZEESQL.EXEC\n\n\nZEESQL.EXEC db_key \n    ( (COMMAND \"command\") | (STATEMENT statement) ) \n    [NOW] \n    [READ_ONLY] \n    [INTO stream] \n    [NO_HEADER] \n    [JSON] \n    [ARGS arg1 arg2 ... argn]\n\n\n\n\nThe EXEC command is the main command of zeeSQL. It allows interaction with the database stored in the \ndb_key\n.\n\n\nIt takes as input the database \ndb_key\n, either a \nCOMMAND\n or a \nSTATEMENT\n, an optional series of flags, and an optional variadic number of arguments.\n\n\nYou need to supply \nEITHER\n a command (using the \nCOMMAND\n flag) or a statement (using the \nSTATEMENT\n flag), but you need one of them.\n\n\nCommand vs Statement\n\n\nThe command is a valid SQL string.\nThe command SQL string can contain arguments in the form \n?n\n. \nThose arguments will be matched to the one provided at the end of the command.\nThe first argument is bound against \n?1\n, NOT against \n?0\n.\nArguments that are not provided will be bound to \nNULL\n.\n\n\nThe statement can be created with the \nZEESQL.STATEMENT\n command.\nThe arguments follow the same logic of the COMMAND variants.\n\n\nExamples\n:\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND \"create table foo(a INT, b string);\"\n1) 1) \"DONE\"\n2) 1) (integer) 0\n\n\n\n\nIn this example, we create a new table.\n\n\n127.0.0.1:6379> ZEESQL.STATEMENT DB NEW insert \"insert into foo values(?1, ?2);\"\n1) 1) \"OK\"\n127.0.0.1:6379> ZEESQL.EXEC DB STATEMENT insert ARGS 1 one\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB STATEMENT insert ARGS 2 two\n1) 1) \"DONE\"\n2) 1) (integer) 1\n\n\n\n\nThen we create a new STATEMENT to insert values, and we execute the statement twice.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND \"select * from foo;\"\n1) 1) \"RESULT\"\n2) 1) \"a\"\n   2) \"b\"\n3) 1) \"INT\"\n   2) \"TEXT\"\n4) 1) (integer) 1\n   2) \"one\"\n5) 1) (integer) 2\n   2) \"two\"\n\n\n\n\nWe queried the values just inserted in the table executing another command.\n\n\nNOW flag\n\n\nBy default \nzeeSQL\n offload the SQL computation to a secondary thread.\nThis free the main Redis thread and keep the Redis instance reactive.\n\n\nThe \nNOW\n flags force \nzeeSQL\n to run the SQL computation in the main Redis thread.\n\n\nREAD_ONLY flag\n\n\nThe \nREAD_ONLY\n flags communicate to \nzeeSQL\n that the execution will not modify the database.\n\n\nIf the execution might modify the database, and the \nREAD_ONLY\n flag is passed, \nzeeSQL\n will return an error.\n\n\nPassing the \nREAD_ONLY\n flags allow \nzeeSQL\n to not replicate the command.\nPossibly saving computing resources of the replicas.\n\n\nExamples\n:\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND \"select * from foo where a > ?1;\" READ_ONLY ARGS 1\n1) 1) \"RESULT\"\n2) 1) \"a\"\n   2) \"b\"\n3) 1) \"INT\"\n   2) \"TEXT\"\n4) 1) (integer) 2\n   2) \"two\"\n\n\n\n\nHere we correctly used the \nREAD_ONLY\n flag to communicate with \nzeeSQL\n that the command will not modify the database.\n\n\nzeeSQL\n correctly executes the query.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND \"insert into foo values(3, 'three')\" READ_ONLY\n(error) Statement is not read only but it may modify the database, use `EXEC` instead.\n\n\n\n\nIn this other case, we ask \nzeeSQL\n to modify the database while using the \nREAD_ONLY\n flag.\n\n\nzeeSQL\n correctly refuses to modify the database and returns an error.\n\n\nNO_HEADER flag\n\n\nBy default \nzeeSQL\n returns information about the result set.\nIt returns the name of the columns and their type.\n\n\nThis information might not be useful nor desirable.\n\n\nWith the \nNO_HEADER\n flag, only the result itself is returned.\n\n\nExamples\n:\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND \"select a as number_as_integer, b as number_as_string from foo;\"\n1) 1) \"RESULT\"\n2) 1) \"number_as_integer\"\n   2) \"number_as_string\"\n3) 1) \"INT\"\n   2) \"TEXT\"\n4) 1) (integer) 1\n   2) \"one\"\n5) 1) (integer) 2\n   2) \"two\"\n\n\n\n\nThis is the default result from \nzeeSQL\n. It reports the name of the columns (in this case \nnumber_as_integer\n and \nnumber_as_string\n and their type \nINT\n and \nTEXT\n).\n\n\nIf we are not intereted in such information:\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND \"select a as number_as_integer, b as number_as_string from foo;\" NO_HEADER\n1) 1) \"RESULT\"\n2) 1) (integer) 1\n   2) \"one\"\n3) 1) (integer) 2\n   2) \"two\"\n\n\n\n\nthe \nNO_HEADER\n flags will omit it for us.\n\n\nJSON flag\n\n\nBy default \nzeeSQL\n returns its result as an array of array.\nThis makes parsing the result a little complex in some programming languages.\n\n\nThe JSON flags instruct \nzeeSQL\n to return a single JSON string as result.\n\n\nExamples\n:\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND \"select a as number_as_integer, b as number_as_string  from foo;\" JSON\n\"{\\\"rows\\\":[{\\\"number_as_integer\\\":1,\\\"number_as_string\\\":\\\"one\\\"},{\\\"number_as_integer\\\":2,\\\"number_as_string\\\":\\\"two\\\"}],\\\"number_of_rows\\\":2,\\\"columns\\\":{\\\"number_as_integer\\\":\\\"INT\\\",\\\"number_as_strin\ng\\\":\\\"TEXT\\\"}}\"\n\n\n\n\nThe JSON is valid JSON even if compressed:\n\n\n$ redis-cli ZEESQL.EXEC DB COMMAND \"select a as number_as_integer, b as number_as_string  from foo;\" JSON | jq\n{\n  \"rows\": [\n    {\n      \"number_as_integer\": 1,\n      \"number_as_string\": \"one\"\n    },\n    {\n      \"number_as_integer\": 2,\n      \"number_as_string\": \"two\"\n    }\n  ],\n  \"number_of_rows\": 2,\n  \"columns\": {\n    \"number_as_integer\": \"INT\",\n    \"number_as_string\": \"TEXT\"\n  }\n}\n\n\n\n\nOf course, this can be combined with the \nNO_HEADER\n flag.\n\n\n$ redis-cli ZEESQL.EXEC DB COMMAND \"select a as number_as_integer, b as number_as_string  from foo;\" JSON NO_HEADER | jq\n{\n  \"rows\": [\n    {\n      \"number_as_integer\": 1,\n      \"number_as_string\": \"one\"\n    },\n    {\n      \"number_as_integer\": 2,\n      \"number_as_string\": \"two\"\n    }\n  ]\n}\n\n\n\n\nINTO stream\n\n\nzeeSQL\n can push the result of a computation in a Redis Stream.\n\n\nThis is desirable if you want to:\n\n\n\n\nconsume the result at a later time,\n\n\nor cache the result, \n\n\nor if the result is rather big and you don't want to send all of it over the network.\n\n\n\n\nThe \nINTO stream\n option will inform \nzeeSQL\n to push the result of the computation into the Redis STREAM called \nstream\n.\n\n\nThe \nINTO stream\n option is available only if the query is marked as \nREAD_ONLY\n.\n\n\nThe command executes \nXADD\n to the stream.\n\n\nIf the stream does not exist a new one is created. \n\n\nIf the stream already exists the rows are simply appended.\n\n\nThe command itself is eager, hence it computes the whole result, append it into the stream, and then it returns. \nOnce the command returns, the whole result set is already in the Redis stream.\n\n\nThe return value of the command depends on the result of the query:\n\n\nIf the result of the query is empty, it simply returns \n[\"DONE\", 0]\n.\n\n\nIf at least one row is returned by the query the command returns:\n\n\n1.the name of the stream where it appended the resulting rows, which is always the one passed as input\n2. the first ID added to the stream \n3. the last ID added to the stream \n4. and the total number of entries added to the stream.\n\n\nUsing a standard Redis Stream all the standard consideration applies.\n\n\n\n\nThe stream is not deleted by zeeSQL, hence it can be used for caching, on the other hand too many streams will use memory.\n\n\nThe stream uses a standard Redis key, in a cluster environment you should be sure that the database that is executing the query and the stream that will accommodate the results are on the same cluster node. \n\n\n\n\nThis can be accomplished easily by forcing the stream name to hash to the same cluster node of the database, it is sufficient to use a \nstream_name\n composed as such \n{db_key}:what:ever:here\n. Redis will hash only the part between the \n{\n and \n}\n to compute the cluster node.\n3. The result can be consumed using the standard \nRedis streams commands\n, two good starting points are \nXREAD\n and \nXRANGE\n.\n\n\nThe key of the stream elements are the tuple \n(type, column name)\n separated by a colon \n:\n.\n\n\nExamples\n:\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND \"select * from foo;\" INTO foo_stream\n(error) Asked a STREAM, but the query is not `READ_ONLY` (flag not set), this is not supported.\n\n\n\n\nAt first, we tried to push the result of a query that is not marked as \nREAD_ONLY\n and this correctly fails.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND \"select * from foo where a > 100;\" READ_ONLY INTO foo_stream\n1) 1) \"DONE\"\n2) 1) (integer) 0\n\n\n\n\nAbove we execute a query that returns an empty result.\n\n\nzeeSQL\n simply communicates to us that the result is empty.\n\n\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND \"select * from foo;\" READ_ONLY INTO foo_stream                                                                                       1) 1) \"RESULT\"\n2) 1) \"foo_stream\"\n   2) \"1612797707753-0\"\n   3) \"1612797707753-1\"\n   4) (integer) 2\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND \"select * from foo;\" READ_ONLY INTO foo_stream JSON\n\"{\\\"rows\\\":[{\\\"stream\\\":\\\"foo_stream\\\",\\\"first_id\\\":\\\"1612797722505-0\\\",\\\"last_id\\\":\\\"1612797722505-1\\\",\\\"size\\\":2}]}\"\n\n\n\n\nThen we push into the Redis stream \nfoo_stream\n the result of the query \nselect * from foo\n.\n\n\nWe do it twice, once using the standard return and the second time using the JSON return.\n\n\nWe pushed twice, a query that returned two results, so we expect 4 elements in the stream.\n\n\n127.0.0.1:6379> XLEN foo_stream\n(integer) 4\n\n\n\n\nWe can read the elements from the stream using the standard Redis stream interface.\nIn this case, we are going to read only the first two elements.\n\n\n127.0.0.1:6379> XRANGE foo_stream - + COUNT 2\n1) 1) \"1612797707753-0\"\n   2) 1) \"int:a\"\n      2) \"1\"\n      3) \"text:b\"\n      4) \"one\"\n2) 1) \"1612797707753-1\"\n   2) 1) \"int:a\"\n      2) \"2\"\n      3) \"text:b\"\n      4) \"two\"\n\n\n\n\nComplexity\n: Besides the complexity of the query, the \nINTO stream\n options add the complexity of adding each row to the Redis stream, which is \nO(n)\n where \nn\n is the amount of row returned by the query.\n\n\nSee also\n:\n\n\n\n\nRedis Streams Intro\n\n\nRedis Streams Commands\n\n\nXADD\n\n\nXREAD\n\n\nXRANGE\n\n\n\n\nARGS arguments\n\n\nThe ARGS arguments are used to pass arguments to the statement or command.\n\n\nThey are variadic, and you can pass as many as you need.\n\n\nIn the SQL, the first argument will be bound to \n?1\n, the second to \n?2\n, and so on.\nPlease note that the first argument is NOT bound to \n?0\n.\n\n\nIf an argument is not bound, for instance, you pass a query with \n?4\n but only provide 3 arguments, then, that argument is bound to \nNULL\n.\n\n\nRedis works using a text protocol, all the arguments are encoded as text, hence the module is forced to use the procedure \nsqlite3_bind_text\n, however, SQLite is smart enough to recognize numbers and treat them correctly. Numbers will be treated as numbers and text will be treated as text.\n\n\nSee also\n:\n\n\n\n\nSQLite \nsqlite3_prepare_v2\n\n\nSQLite \nstatement\n aka \nsqlite3_stmt\n\n\nSQLite \nsqlite3_step\n\n\nSQLite \nPRAGMA\ns\n\n\nRedis Blocking Command\n\n\n\n\nZEESQL.QUERY\n\n\nZEESQL.QUERY db_key \n    ( (COMMAND \"command\") | (STATEMENT statement) ) \n    [NOW] \n    [INTO stream] \n    [NO_HEADER] \n    [JSON] \n    [ARGS arg1 arg2 ... argn]\n\n\n\n\nThis command behaves similarly to \nZEESQL.EXEC\n but it imposes an additional constraint on the statement it executes.\n\n\nIt only executes the statement if it is a read-only operation, otherwise, it returns an error.\n\n\nA read-only operation is defined by the result of calling \nsqlite3_stmt_readonly\n on the compiled statement.\n\n\nThe statement is executed if and only if \nsqlite3_stmt_readonly\n returns true.\n\n\nThis command is exactly like \nZEESQL.EXEC ... READ_ONLY\n however it can be executed against Redis replicas.\n\n\nComplexity\n: Similar to \nZEESQL.EXEC\n, however, if a statement is not read-only it is aborted immediately and it does return an appropriate error.\n\n\nSee also\n:\n\n\n\n\nSQLite \nsqlite3_prepare_v2\n\n\nSQLite \nstatement\n aka \nsqlite3_stmt\n\n\nSQLite \nsqlite3_step\n\n\nSQLite \nPRAGMA\ns\n\n\nRedis Blocking Command\n \n\n\nZEESQL.EXEC\n\n\nSQLite \nsqlite3_stmt_readonly\n\n\nZEESQL.QUERY_STATEMENT\n \n\n\n\n\nZEESQL.STATEMENT\n\n\nZEESQL.STATEMENT db_key\n    (\n        (NEW stmt \"query\" [CAN_UPDATE]) | \n        (DELETE stmt) | \n        (UPDATE stmt \"query\" [CAN_CREATE]) |\n        (SHOW stmt) |\n        LIST\n    )\n    [NOW]\n\n\n\n\nThis command manages \nzeeSQL\n statements.\n\n\nA statement is a pre-compiled SQL query, if you are going to execute your query over and over again, it is a good idea to make it into a statement.\nUnder the hood it is a \nsqlite statement\n.\n\n\nStatements can be used in the \nZEESQL.EXEC db_key STATEMENT stmt\n command and in the \nZEESQL.QUERY db_key STATEMENT stmt\n command.\n\n\nFive different actions can be invoked with the STATEMENT command.\n\n\n\n\nCreate a new statement with the \nNEW\n option.\n\n\nDelete a statement with the \nDELETE\n option.\n\n\nUpdate a statement with the \nUPDATE\n option.\n\n\nShow the SQL behind a statement with the \nSHOW\n option.\n\n\nList all the statements with the \nLIST\n option.\n\n\n\n\nThe \nSTATEMENT\n command includes the \nNOW\n flag. \nThe \nNOW\n flag forces \nzeeSQL\n to execute the action in the main Redis thread.\nIn standard operations mode, it should not be used.\n\n\nNEW\n\n\nThe \nNEW\n option takes as input the name to associate with the statement and an SQL query to compile.\n\n\nThe command compiles the SQL query into a pre-compiled statement, and associate it with the name.\n\n\nThe \nCAN_UPDATE\n flag to the \nNEW\n command, instruct \nzeeSQL\n to behave as an \nUPDATE\n if the statement name is already allocated to an old statement.\nOtherwise, without the \nCAN_UPDATE\n flag, if the statement name is already used by a different statement, the command fails with an error.\n\n\nDELETE\n\n\nThe \nDELETE\n option deletes a statement.\n\n\nUPDATE\n\n\nThe \nUPDATE\n option updates a statement, associating the old name with the statement compiled from the SQL query.\n\n\nIf the name does not exists, \nUPDATE\n fails, unless the \nCAN_CREATE\n flag is provided.\nIn such a case \nUPDATE\n behave like \nNEW\n.\n\n\nSHOW\n\n\nThe \nSHOW\n option returns the SQL query behind one statement.\n\n\nLIST\n\n\nThe \nLIST\n option returns all the statements and their SQL queries.\n\n\nBoth \nSHOW\n and \nLIST\n will report:\n\n\n\n\nThe name of the statement\n\n\nThe SQL query associate with the statement\n\n\nThe number of parameters the statement expects\n\n\nIf the statement is read only or not\n\n\n\n\nComplexity\n: Operation on the statements happens in constant time O(1). Listing the statements happens in O(n) with \nn\n number of statements present in the database.\n\n\nExamples\n:\n\n\nAt first we create a new statement, \n\n\n127.0.0.1:6379> ZEESQL.STATEMENT DB NEW select_1 \"SELECT 1;\"\n1) 1) \"OK\"\n\n\n\n\nWe can then list, the statement:\n\n\n127.0.0.1:6379> ZEESQL.STATEMENT DB LIST\n1) 1) \"RESULT\"\n2) 1) \"identifier\"\n   2) \"SQL\"\n   3) \"parameters_count\"\n   4) \"read_only\"\n3) 1) \"TEXT\"\n   2) \"TEXT\"\n   3) \"INT\"\n   4) \"INT\"\n4) 1) \"select_1\"\n   2) \"SELECT 1;\"\n   3) (integer) 0\n   4) (integer) 1\n\n\n\n\nThe statement can be updated, but we need to use the \nUPDATE\n command or the \nCAN_UPDATE\n flag.\n\n\n127.0.0.1:6379> ZEESQL.STATEMENT DB NEW select_1 \"SELECT '1';\"\n(error) The statement is already present in the database, try with UPDATE_STATEMENT\n127.0.0.1:6379> ZEESQL.STATEMENT DB NEW select_1 \"SELECT '1';\" CAN_UPDATE\n1) 1) \"OK\"\n127.0.0.1:6379> ZEESQL.STATEMENT DB UPDATE select_1 \"SELECT '1';\"\n1) 1) \"OK\"\n\n\n\n\nWe change \nselect_1\n to return a string and not an integer.\n\n\n127.0.0.1:6379> ZEESQL.STATEMENT DB UPDATE select_plus_one \"SELECT ?1 + 1;\" CAN_CREATE\n1) 1) \"OK\"\n\n\n\n\nWe create another statement, this time we create the statement with the \nUPDATE\n command and the \nCAN_CREATE\n flag.\n\n\n127.0.0.1:6379> ZEESQL.STATEMENT DB LIST\n1) 1) \"RESULT\"\n2) 1) \"identifier\"\n   2) \"SQL\"\n   3) \"parameters_count\"\n   4) \"read_only\"\n3) 1) \"TEXT\"\n   2) \"TEXT\"\n   3) \"INT\"\n   4) \"INT\"\n4) 1) \"select_1\"\n   2) \"SELECT '1';\"\n   3) (integer) 0\n   4) (integer) 1\n5) 1) \"select_plus_one\"\n   2) \"SELECT ?1 + 1;\"\n   3) (integer) 1\n   4) (integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB STATEMENT select_plus_one NO_HEADER ARGS 5\n1) 1) \"RESULT\"\n2) 1) (integer) 6\n\n\n\n\nSee also\n:\n\n\n\n\nSQLite \nsqlite3_prepare_v2\n\n\nSQLite \nstatement\n aka \nsqlite3_stmt\n\n\nSQLite bindings, \nsqlite3_bind_text\n\n\nRedis Blocking Command\n\n\n\n\nZEESQL.COPY\n\n\nZEESQL.COPY \n    FROM db_key_source \n    TO db_key_destination \n    [NOW] \n\n\n\n\nThe command copies the source database into the destination database.\n\n\nThe content of the destination databases is completely ignored and lost.\n\n\nIt is not important if the databases are stored in memory or backed by disk, the \nCOPY\n command will work nevertheless.\n\n\nThis command is useful to:\n\n\n\n\nCreate backups of databases\n\n\nLoad data from slow, disk-based, databases into a fast in-memory one\n\n\nTo persist data from an in-memory database into a disk-based database\n\n\nInitialize a database with a predefined status\n\n\n\n\nUsually, the destination database is an empty database just created, while the source one is a database where we have been working for a while.\n\n\nThis command use the \nbackup API\n of sqlite.\n\n\nComplexity\n: The complexity is linear on the number of pages (dimension) of the source database, beware it can be \"slow\" if the source database is big, during the copy the \nsource\n database is busy and it cannot serve other queries. \n\n\nExample\n:\n\n\n127.0.0.1:6379> ZEESQL.CREATE_DB DB01\n1) 1) \"OK\"\n127.0.0.1:6379> ZEESQL.EXEC DB01 COMMAND \"create table foo(a, b);\"\n1) 1) \"DONE\"\n2) 1) (integer) 0\n127.0.0.1:6379> ZEESQL.EXEC DB01 COMMAND \"insert into foo values(1,2),(3,4);\"\n1) 1) \"DONE\"\n2) 1) (integer) 2\n127.0.0.1:6379> ZEESQL.CREATE_DB DB02\n1) 1) \"OK\"\n127.0.0.1:6379> ZEESQL.EXEC DB02 COMMAND \"select * from foo\"\n(error) no such table: foo\n127.0.0.1:6379> ZEESQL.COPY FROM DB01 TO DB02\n1) 1) \"OK\"\n127.0.0.1:6379> ZEESQL.EXEC DB02 COMMAND \"select * from foo\"\n1) 1) \"RESULT\"\n2) 1) \"a\"\n   2) \"b\"\n3) 1) \"INT\"\n   2) \"INT\"\n4) 1) (integer) 1\n   2) (integer) 2\n5) 1) (integer) 3\n   2) (integer) 4\n\n\n\n\nIn the example we create a database, we create a table, and then we pushed few rows into the table.\n\n\nWe then create another database, but this time we didn't create the table, neither pushed any row.\n\n\nAs expected, trying to query the second database returned an error.\n\n\nAfter copying the content of the first database into the second, the second database has become a perfect copy of the first one.\n\n\nSee also\n:\n\n\n\n\nBackup API\n\n\n\n\nZEESQL.INDEX\n\n\nThe index command accepts 3 different options:\n\n\n\n\nNEW\n\n\nLIST\n\n\nDELETE\n\n\n\n\nWe will illustrate them separately.\n\n\nZEESQL.INDEX NEW\n\n\nZEESQL.INDEX db_key \n    NEW\n    TABLE table_name\n    [PREFIX prefix]\n    SCHEMA column_name column_type [column_name column_type ...]\n\n\n\n\nCreates a new secondary index table for the Redis hashes.\n\n\nThe secondary index will refer to the table \ntable_name\n and will use the columns indicated in the \nSCHEMA\n parameter.\n\n\ncolumn_type\n can be whatever is accepted by SQLite as column name, suggestions are \nTEXT\n, \nINT\n, \nFLOAT\n or \nBLOB\n.\n\n\nIf a prefix is provided, only the Redis hashes that start with that prefix are indexed in the table.\nIf the prefix is omitted, the \n*\n prefix (catch-all) is assumed.\n\n\nIf the table does not exists when the index is created, \nzeeSQL\n creates it.\n\n\nIf the table already exists, \nzeeSQL\n takes no action.\nHowever, if the table exists but contains the wrong columns, \nzeeSQL\n may find it impossible to insert the hashes into the secondary index.\n\n\nIt is possible to create multiple indexes, with the same table, same schema, but different prefix.\n\n\nzeeSQL\n store in the secondary index table, the main Redis hash key, as primary key.\n\n\nThe table created by \nzeeSQL\n behaves like any other table, so it can be queried, modified, and indexed, using the standard \nZEESQL.EXEC\n interface.\n\n\nNo steps are taken to avoid manual deletions or updates of the secondary index table by the user.\n\n\nSecondary indexes are univocally identified by the combination of the table in which they write and the prefix.\n\n\nExample\n:\n\n\nIn this example, we can see how to create a secondary index, and how the secondary index automatically keeps the values between Redis and zeeSQL in synchronism.\n\n\n127.0.0.1:6379> ZEESQL.INDEX DB NEW TABLE users prefix user:* SCHEMA username STRING score INT\nOK\n127.0.0.1:6379> HMSET user:1001 username aaa score 0\nOK\n127.0.0.1:6379> HMSET user:1002 username bbb score 0\nOK\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND \"select * from users\"\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"username\"\n   3) \"score\"\n3) 1) \"TEXT\"\n   2) \"TEXT\"\n   3) \"INT\"\n4) 1) \"user:1001\"\n   2) \"aaa\"\n   3) (integer) 0\n5) 1) \"user:1002\"\n   2) \"bbb\"\n   3) (integer) 0\n127.0.0.1:6379> HINCRBY user:1002 score 3\n(integer) 3\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND \"select * from users\"\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"username\"\n   3) \"score\"\n3) 1) \"TEXT\"\n   2) \"TEXT\"\n   3) \"INT\"\n4) 1) \"user:1001\"\n   2) \"aaa\"\n   3) (integer) 0\n5) 1) \"user:1002\"\n   2) \"bbb\"\n   3) (integer) 3\n\n\n\n\nZEESQL.INDEX LIST\n\n\nThe list option shows the active secondary index.\n\n\nThe secondary indexes are identified by the table in which they write and by the prefix they use to filter the keys.\n\n\nExample\n:\n\n\n127.0.0.1:6379> ZEESQL.INDEX DB LIST\n1) 1) \"RESULT\"\n2) 1) \"users\"\n   2) \"user:*\"\n127.0.0.1:6379> ZEESQL.INDEX DB NEW TABLE games prefix games:* SCHEMA first_player STRING second_player STRING score_player_1 INT score_player_2 INT\nOK\n127.0.0.1:6379> ZEESQL.INDEX DB LIST\n1) 1) \"RESULT\"\n2) 1) \"users\"\n   2) \"user:*\"\n3) 1) \"games\"\n   2) \"games:*\"\n\n\n\n\nZEESQL.INDEX DELETE\n\n\nZEESQL.INDEX db_key \n    DELETE\n    TABLE table_name\n    [PREFIX prefix]\n\n\n\n\nThe \nDELETE\n option removes a secondary index.\n\n\nHashes that match the prefix are not inserted anymore in the table after the index is removed.\n\n\nThe \nDELETE\n option takes as input the table and the prefix that identifies the secondary index to remove.\n\n\nIf the prefix is omitted the \n*\n (catch-all) prefix is assumed.\n\n\nExample\n:\n\n\n127.0.0.1:6379> ZEESQL.INDEX DB NEW TABLE users PREFIX user:* SCHEMA username STRING score INT\nOK\n127.0.0.1:6379> HMSET user:1001 username first_user score 12\nOK\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND \"select * from users\" NO_HEADER\n1) 1) \"RESULT\"\n2) 1) \"user:1001\"\n   2) \"first_user\"\n   3) (integer) 12\n127.0.0.1:6379> ZEESQL.INDEX DB DELETE TABLE users PREFIX user:*\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> HMSET user:1002 username second_user score 5\nOK\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND \"select * from users\" NO_HEADER\n1) 1) \"RESULT\"\n2) 1) \"user:1001\"\n   2) \"first_user\"\n   3) (integer) 12\n\n\n\n\nIn the example, we first create an index.\n\n\nThen we add a Redis hash that matches the secondary index prefix, so it is added to the secondary index table.\n\n\nThen, delete the index.\n\n\nAnd we can confirm that new users are not added any more to the secondary index table.\n\n\nZEESQL.LICENSE\n\n\nZEESQL.LICENSE\n    ( SET \"license\" ) | SHOW\n\n\n\n\nThe \nSET\n option will set the license to use for \nzeeSQL\n.\n\n\nThe license is first checked against our backend server, and if the license is correct, it will return \nOK\n otherwise it will return an error.\n\n\nIt is required an internet connection to set the license.\n\n\nThe \nSHOW\n option will show the license that is actually in use in your \nzeeSQL\n process.",
            "title": "References"
        },
        {
            "location": "/references/#references",
            "text": "This document explains all the API that zeeSQL provide to the users.  This document refers to the latest API, but we commit to backward-compatible API.  For each command, it exposes first the name and then the syntax, and finally a brief explanation of what is going on inside the code.  Where is possible, it provides also an estimate of the complexity but since we are talking about databases not all queries have the same time and spatial complexity.  Finally, if it is appropriate the document also provides several references to external material that the interested reader can use to understand better the dynamics of every command.",
            "title": "References"
        },
        {
            "location": "/references/#zeesqlcreate_db",
            "text": "ZEESQL.CREATE_DB db_key [PATH path]  This command creates a new DB and associates it with the key.  The path argument is optional and, if provided is the file that SQLite will use.\nIt can be an existing SQLite file or it can be a not existing file.  If the file exists and if it is a regular SQLite file that database will be used.\nIf the file does not exist a new file will be created.  If the path is not provided it will open an in-memory database. Not providing a path is equivalent to provide the special string  :memory:  as the path argument.  After opening the database it inserts metadata into it and then starts a thread loop.  Complexity : O(1), it means constant, it does not necessarily mean  fast . However, is fast enough for any use case facing human users (eg create a new database for every user logging into a website.)  Examples :  127.0.0.1:6379> ZEESQL.CREATE_DB DB \n1) 1) \"OK\"  This command created an in-memory database.\nPersistency is managed by Redis with AOF or RDB following the setting of your Redis instance.  127.0.0.1:6379> ZEESQL.CREATE_DB on_disk_db PATH /tmp/foo.sqlite\n1) 1) \"OK\"  This command created a database that uses a file as storage support, in this case  /tmp/foo.sqlite .  If the file does not exist, it is created.  If the file is already an SQLite database, it gets used immediately with all the data already loaded.  If the file is not an SQLite database, an error is raised.  See also :    SQLite  sqlite3_open_v2",
            "title": "ZEESQL.CREATE_DB"
        },
        {
            "location": "/references/#del",
            "text": "DEL db_key [key ...]  This command is a generic command from Redis.  It eliminates keys from Redis itself, as well if the key is a RediSQL database create with  ZEESQL.CREATE_DB  it will eliminate the SQLite database, stop the thread loop and clean up everything left.  If the database is backed by a file the file will be closed, but it won't be deleted.  Complexity : DEL is O(N) on the number of keys, if you are only eliminating the key associated with the SQLite database will be constant, O(1).  Examples :  127.0.0.1:6379> ZEESQL.CREATE_DB DB \n1) 1) \"OK\"\n127.0.0.1:6379> DEL DB\n(integer) 1  See also :    SQLite  sqlite3_close  Redis  DEL",
            "title": "DEL"
        },
        {
            "location": "/references/#zeesqlexec",
            "text": "ZEESQL.EXEC db_key \n    ( (COMMAND \"command\") | (STATEMENT statement) ) \n    [NOW] \n    [READ_ONLY] \n    [INTO stream] \n    [NO_HEADER] \n    [JSON] \n    [ARGS arg1 arg2 ... argn]  The EXEC command is the main command of zeeSQL. It allows interaction with the database stored in the  db_key .  It takes as input the database  db_key , either a  COMMAND  or a  STATEMENT , an optional series of flags, and an optional variadic number of arguments.  You need to supply  EITHER  a command (using the  COMMAND  flag) or a statement (using the  STATEMENT  flag), but you need one of them.",
            "title": "ZEESQL.EXEC"
        },
        {
            "location": "/references/#command-vs-statement",
            "text": "The command is a valid SQL string.\nThe command SQL string can contain arguments in the form  ?n . \nThose arguments will be matched to the one provided at the end of the command.\nThe first argument is bound against  ?1 , NOT against  ?0 .\nArguments that are not provided will be bound to  NULL .  The statement can be created with the  ZEESQL.STATEMENT  command.\nThe arguments follow the same logic of the COMMAND variants.  Examples :  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND \"create table foo(a INT, b string);\"\n1) 1) \"DONE\"\n2) 1) (integer) 0  In this example, we create a new table.  127.0.0.1:6379> ZEESQL.STATEMENT DB NEW insert \"insert into foo values(?1, ?2);\"\n1) 1) \"OK\"\n127.0.0.1:6379> ZEESQL.EXEC DB STATEMENT insert ARGS 1 one\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB STATEMENT insert ARGS 2 two\n1) 1) \"DONE\"\n2) 1) (integer) 1  Then we create a new STATEMENT to insert values, and we execute the statement twice.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND \"select * from foo;\"\n1) 1) \"RESULT\"\n2) 1) \"a\"\n   2) \"b\"\n3) 1) \"INT\"\n   2) \"TEXT\"\n4) 1) (integer) 1\n   2) \"one\"\n5) 1) (integer) 2\n   2) \"two\"  We queried the values just inserted in the table executing another command.",
            "title": "Command vs Statement"
        },
        {
            "location": "/references/#now-flag",
            "text": "By default  zeeSQL  offload the SQL computation to a secondary thread.\nThis free the main Redis thread and keep the Redis instance reactive.  The  NOW  flags force  zeeSQL  to run the SQL computation in the main Redis thread.",
            "title": "NOW flag"
        },
        {
            "location": "/references/#read_only-flag",
            "text": "The  READ_ONLY  flags communicate to  zeeSQL  that the execution will not modify the database.  If the execution might modify the database, and the  READ_ONLY  flag is passed,  zeeSQL  will return an error.  Passing the  READ_ONLY  flags allow  zeeSQL  to not replicate the command.\nPossibly saving computing resources of the replicas.  Examples :  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND \"select * from foo where a > ?1;\" READ_ONLY ARGS 1\n1) 1) \"RESULT\"\n2) 1) \"a\"\n   2) \"b\"\n3) 1) \"INT\"\n   2) \"TEXT\"\n4) 1) (integer) 2\n   2) \"two\"  Here we correctly used the  READ_ONLY  flag to communicate with  zeeSQL  that the command will not modify the database.  zeeSQL  correctly executes the query.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND \"insert into foo values(3, 'three')\" READ_ONLY\n(error) Statement is not read only but it may modify the database, use `EXEC` instead.  In this other case, we ask  zeeSQL  to modify the database while using the  READ_ONLY  flag.  zeeSQL  correctly refuses to modify the database and returns an error.",
            "title": "READ_ONLY flag"
        },
        {
            "location": "/references/#no_header-flag",
            "text": "By default  zeeSQL  returns information about the result set.\nIt returns the name of the columns and their type.  This information might not be useful nor desirable.  With the  NO_HEADER  flag, only the result itself is returned.  Examples :  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND \"select a as number_as_integer, b as number_as_string from foo;\"\n1) 1) \"RESULT\"\n2) 1) \"number_as_integer\"\n   2) \"number_as_string\"\n3) 1) \"INT\"\n   2) \"TEXT\"\n4) 1) (integer) 1\n   2) \"one\"\n5) 1) (integer) 2\n   2) \"two\"  This is the default result from  zeeSQL . It reports the name of the columns (in this case  number_as_integer  and  number_as_string  and their type  INT  and  TEXT ).  If we are not intereted in such information:  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND \"select a as number_as_integer, b as number_as_string from foo;\" NO_HEADER\n1) 1) \"RESULT\"\n2) 1) (integer) 1\n   2) \"one\"\n3) 1) (integer) 2\n   2) \"two\"  the  NO_HEADER  flags will omit it for us.",
            "title": "NO_HEADER flag"
        },
        {
            "location": "/references/#json-flag",
            "text": "By default  zeeSQL  returns its result as an array of array.\nThis makes parsing the result a little complex in some programming languages.  The JSON flags instruct  zeeSQL  to return a single JSON string as result.  Examples :  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND \"select a as number_as_integer, b as number_as_string  from foo;\" JSON\n\"{\\\"rows\\\":[{\\\"number_as_integer\\\":1,\\\"number_as_string\\\":\\\"one\\\"},{\\\"number_as_integer\\\":2,\\\"number_as_string\\\":\\\"two\\\"}],\\\"number_of_rows\\\":2,\\\"columns\\\":{\\\"number_as_integer\\\":\\\"INT\\\",\\\"number_as_strin\ng\\\":\\\"TEXT\\\"}}\"  The JSON is valid JSON even if compressed:  $ redis-cli ZEESQL.EXEC DB COMMAND \"select a as number_as_integer, b as number_as_string  from foo;\" JSON | jq\n{\n  \"rows\": [\n    {\n      \"number_as_integer\": 1,\n      \"number_as_string\": \"one\"\n    },\n    {\n      \"number_as_integer\": 2,\n      \"number_as_string\": \"two\"\n    }\n  ],\n  \"number_of_rows\": 2,\n  \"columns\": {\n    \"number_as_integer\": \"INT\",\n    \"number_as_string\": \"TEXT\"\n  }\n}  Of course, this can be combined with the  NO_HEADER  flag.  $ redis-cli ZEESQL.EXEC DB COMMAND \"select a as number_as_integer, b as number_as_string  from foo;\" JSON NO_HEADER | jq\n{\n  \"rows\": [\n    {\n      \"number_as_integer\": 1,\n      \"number_as_string\": \"one\"\n    },\n    {\n      \"number_as_integer\": 2,\n      \"number_as_string\": \"two\"\n    }\n  ]\n}",
            "title": "JSON flag"
        },
        {
            "location": "/references/#into-stream",
            "text": "zeeSQL  can push the result of a computation in a Redis Stream.  This is desirable if you want to:   consume the result at a later time,  or cache the result,   or if the result is rather big and you don't want to send all of it over the network.   The  INTO stream  option will inform  zeeSQL  to push the result of the computation into the Redis STREAM called  stream .  The  INTO stream  option is available only if the query is marked as  READ_ONLY .  The command executes  XADD  to the stream.  If the stream does not exist a new one is created.   If the stream already exists the rows are simply appended.  The command itself is eager, hence it computes the whole result, append it into the stream, and then it returns. \nOnce the command returns, the whole result set is already in the Redis stream.  The return value of the command depends on the result of the query:  If the result of the query is empty, it simply returns  [\"DONE\", 0] .  If at least one row is returned by the query the command returns:  1.the name of the stream where it appended the resulting rows, which is always the one passed as input\n2. the first ID added to the stream \n3. the last ID added to the stream \n4. and the total number of entries added to the stream.  Using a standard Redis Stream all the standard consideration applies.   The stream is not deleted by zeeSQL, hence it can be used for caching, on the other hand too many streams will use memory.  The stream uses a standard Redis key, in a cluster environment you should be sure that the database that is executing the query and the stream that will accommodate the results are on the same cluster node.    This can be accomplished easily by forcing the stream name to hash to the same cluster node of the database, it is sufficient to use a  stream_name  composed as such  {db_key}:what:ever:here . Redis will hash only the part between the  {  and  }  to compute the cluster node.\n3. The result can be consumed using the standard  Redis streams commands , two good starting points are  XREAD  and  XRANGE .  The key of the stream elements are the tuple  (type, column name)  separated by a colon  : .  Examples :  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND \"select * from foo;\" INTO foo_stream\n(error) Asked a STREAM, but the query is not `READ_ONLY` (flag not set), this is not supported.  At first, we tried to push the result of a query that is not marked as  READ_ONLY  and this correctly fails.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND \"select * from foo where a > 100;\" READ_ONLY INTO foo_stream\n1) 1) \"DONE\"\n2) 1) (integer) 0  Above we execute a query that returns an empty result.  zeeSQL  simply communicates to us that the result is empty.  127.0.0.1:6379> ZEESQL.EXEC DB COMMAND \"select * from foo;\" READ_ONLY INTO foo_stream                                                                                       1) 1) \"RESULT\"\n2) 1) \"foo_stream\"\n   2) \"1612797707753-0\"\n   3) \"1612797707753-1\"\n   4) (integer) 2\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND \"select * from foo;\" READ_ONLY INTO foo_stream JSON\n\"{\\\"rows\\\":[{\\\"stream\\\":\\\"foo_stream\\\",\\\"first_id\\\":\\\"1612797722505-0\\\",\\\"last_id\\\":\\\"1612797722505-1\\\",\\\"size\\\":2}]}\"  Then we push into the Redis stream  foo_stream  the result of the query  select * from foo .  We do it twice, once using the standard return and the second time using the JSON return.  We pushed twice, a query that returned two results, so we expect 4 elements in the stream.  127.0.0.1:6379> XLEN foo_stream\n(integer) 4  We can read the elements from the stream using the standard Redis stream interface.\nIn this case, we are going to read only the first two elements.  127.0.0.1:6379> XRANGE foo_stream - + COUNT 2\n1) 1) \"1612797707753-0\"\n   2) 1) \"int:a\"\n      2) \"1\"\n      3) \"text:b\"\n      4) \"one\"\n2) 1) \"1612797707753-1\"\n   2) 1) \"int:a\"\n      2) \"2\"\n      3) \"text:b\"\n      4) \"two\"  Complexity : Besides the complexity of the query, the  INTO stream  options add the complexity of adding each row to the Redis stream, which is  O(n)  where  n  is the amount of row returned by the query.  See also :   Redis Streams Intro  Redis Streams Commands  XADD  XREAD  XRANGE",
            "title": "INTO stream"
        },
        {
            "location": "/references/#args-arguments",
            "text": "The ARGS arguments are used to pass arguments to the statement or command.  They are variadic, and you can pass as many as you need.  In the SQL, the first argument will be bound to  ?1 , the second to  ?2 , and so on.\nPlease note that the first argument is NOT bound to  ?0 .  If an argument is not bound, for instance, you pass a query with  ?4  but only provide 3 arguments, then, that argument is bound to  NULL .  Redis works using a text protocol, all the arguments are encoded as text, hence the module is forced to use the procedure  sqlite3_bind_text , however, SQLite is smart enough to recognize numbers and treat them correctly. Numbers will be treated as numbers and text will be treated as text.  See also :   SQLite  sqlite3_prepare_v2  SQLite  statement  aka  sqlite3_stmt  SQLite  sqlite3_step  SQLite  PRAGMA s  Redis Blocking Command",
            "title": "ARGS arguments"
        },
        {
            "location": "/references/#zeesqlquery",
            "text": "ZEESQL.QUERY db_key \n    ( (COMMAND \"command\") | (STATEMENT statement) ) \n    [NOW] \n    [INTO stream] \n    [NO_HEADER] \n    [JSON] \n    [ARGS arg1 arg2 ... argn]  This command behaves similarly to  ZEESQL.EXEC  but it imposes an additional constraint on the statement it executes.  It only executes the statement if it is a read-only operation, otherwise, it returns an error.  A read-only operation is defined by the result of calling  sqlite3_stmt_readonly  on the compiled statement.  The statement is executed if and only if  sqlite3_stmt_readonly  returns true.  This command is exactly like  ZEESQL.EXEC ... READ_ONLY  however it can be executed against Redis replicas.  Complexity : Similar to  ZEESQL.EXEC , however, if a statement is not read-only it is aborted immediately and it does return an appropriate error.  See also :   SQLite  sqlite3_prepare_v2  SQLite  statement  aka  sqlite3_stmt  SQLite  sqlite3_step  SQLite  PRAGMA s  Redis Blocking Command    ZEESQL.EXEC  SQLite  sqlite3_stmt_readonly  ZEESQL.QUERY_STATEMENT",
            "title": "ZEESQL.QUERY"
        },
        {
            "location": "/references/#zeesqlstatement",
            "text": "ZEESQL.STATEMENT db_key\n    (\n        (NEW stmt \"query\" [CAN_UPDATE]) | \n        (DELETE stmt) | \n        (UPDATE stmt \"query\" [CAN_CREATE]) |\n        (SHOW stmt) |\n        LIST\n    )\n    [NOW]  This command manages  zeeSQL  statements.  A statement is a pre-compiled SQL query, if you are going to execute your query over and over again, it is a good idea to make it into a statement.\nUnder the hood it is a  sqlite statement .  Statements can be used in the  ZEESQL.EXEC db_key STATEMENT stmt  command and in the  ZEESQL.QUERY db_key STATEMENT stmt  command.  Five different actions can be invoked with the STATEMENT command.   Create a new statement with the  NEW  option.  Delete a statement with the  DELETE  option.  Update a statement with the  UPDATE  option.  Show the SQL behind a statement with the  SHOW  option.  List all the statements with the  LIST  option.   The  STATEMENT  command includes the  NOW  flag. \nThe  NOW  flag forces  zeeSQL  to execute the action in the main Redis thread.\nIn standard operations mode, it should not be used.",
            "title": "ZEESQL.STATEMENT"
        },
        {
            "location": "/references/#new",
            "text": "The  NEW  option takes as input the name to associate with the statement and an SQL query to compile.  The command compiles the SQL query into a pre-compiled statement, and associate it with the name.  The  CAN_UPDATE  flag to the  NEW  command, instruct  zeeSQL  to behave as an  UPDATE  if the statement name is already allocated to an old statement.\nOtherwise, without the  CAN_UPDATE  flag, if the statement name is already used by a different statement, the command fails with an error.",
            "title": "NEW"
        },
        {
            "location": "/references/#delete",
            "text": "The  DELETE  option deletes a statement.",
            "title": "DELETE"
        },
        {
            "location": "/references/#update",
            "text": "The  UPDATE  option updates a statement, associating the old name with the statement compiled from the SQL query.  If the name does not exists,  UPDATE  fails, unless the  CAN_CREATE  flag is provided.\nIn such a case  UPDATE  behave like  NEW .",
            "title": "UPDATE"
        },
        {
            "location": "/references/#show",
            "text": "The  SHOW  option returns the SQL query behind one statement.",
            "title": "SHOW"
        },
        {
            "location": "/references/#list",
            "text": "The  LIST  option returns all the statements and their SQL queries.  Both  SHOW  and  LIST  will report:   The name of the statement  The SQL query associate with the statement  The number of parameters the statement expects  If the statement is read only or not   Complexity : Operation on the statements happens in constant time O(1). Listing the statements happens in O(n) with  n  number of statements present in the database.  Examples :  At first we create a new statement,   127.0.0.1:6379> ZEESQL.STATEMENT DB NEW select_1 \"SELECT 1;\"\n1) 1) \"OK\"  We can then list, the statement:  127.0.0.1:6379> ZEESQL.STATEMENT DB LIST\n1) 1) \"RESULT\"\n2) 1) \"identifier\"\n   2) \"SQL\"\n   3) \"parameters_count\"\n   4) \"read_only\"\n3) 1) \"TEXT\"\n   2) \"TEXT\"\n   3) \"INT\"\n   4) \"INT\"\n4) 1) \"select_1\"\n   2) \"SELECT 1;\"\n   3) (integer) 0\n   4) (integer) 1  The statement can be updated, but we need to use the  UPDATE  command or the  CAN_UPDATE  flag.  127.0.0.1:6379> ZEESQL.STATEMENT DB NEW select_1 \"SELECT '1';\"\n(error) The statement is already present in the database, try with UPDATE_STATEMENT\n127.0.0.1:6379> ZEESQL.STATEMENT DB NEW select_1 \"SELECT '1';\" CAN_UPDATE\n1) 1) \"OK\"\n127.0.0.1:6379> ZEESQL.STATEMENT DB UPDATE select_1 \"SELECT '1';\"\n1) 1) \"OK\"  We change  select_1  to return a string and not an integer.  127.0.0.1:6379> ZEESQL.STATEMENT DB UPDATE select_plus_one \"SELECT ?1 + 1;\" CAN_CREATE\n1) 1) \"OK\"  We create another statement, this time we create the statement with the  UPDATE  command and the  CAN_CREATE  flag.  127.0.0.1:6379> ZEESQL.STATEMENT DB LIST\n1) 1) \"RESULT\"\n2) 1) \"identifier\"\n   2) \"SQL\"\n   3) \"parameters_count\"\n   4) \"read_only\"\n3) 1) \"TEXT\"\n   2) \"TEXT\"\n   3) \"INT\"\n   4) \"INT\"\n4) 1) \"select_1\"\n   2) \"SELECT '1';\"\n   3) (integer) 0\n   4) (integer) 1\n5) 1) \"select_plus_one\"\n   2) \"SELECT ?1 + 1;\"\n   3) (integer) 1\n   4) (integer) 1\n127.0.0.1:6379> ZEESQL.EXEC DB STATEMENT select_plus_one NO_HEADER ARGS 5\n1) 1) \"RESULT\"\n2) 1) (integer) 6  See also :   SQLite  sqlite3_prepare_v2  SQLite  statement  aka  sqlite3_stmt  SQLite bindings,  sqlite3_bind_text  Redis Blocking Command",
            "title": "LIST"
        },
        {
            "location": "/references/#zeesqlcopy",
            "text": "ZEESQL.COPY \n    FROM db_key_source \n    TO db_key_destination \n    [NOW]   The command copies the source database into the destination database.  The content of the destination databases is completely ignored and lost.  It is not important if the databases are stored in memory or backed by disk, the  COPY  command will work nevertheless.  This command is useful to:   Create backups of databases  Load data from slow, disk-based, databases into a fast in-memory one  To persist data from an in-memory database into a disk-based database  Initialize a database with a predefined status   Usually, the destination database is an empty database just created, while the source one is a database where we have been working for a while.  This command use the  backup API  of sqlite.  Complexity : The complexity is linear on the number of pages (dimension) of the source database, beware it can be \"slow\" if the source database is big, during the copy the  source  database is busy and it cannot serve other queries.   Example :  127.0.0.1:6379> ZEESQL.CREATE_DB DB01\n1) 1) \"OK\"\n127.0.0.1:6379> ZEESQL.EXEC DB01 COMMAND \"create table foo(a, b);\"\n1) 1) \"DONE\"\n2) 1) (integer) 0\n127.0.0.1:6379> ZEESQL.EXEC DB01 COMMAND \"insert into foo values(1,2),(3,4);\"\n1) 1) \"DONE\"\n2) 1) (integer) 2\n127.0.0.1:6379> ZEESQL.CREATE_DB DB02\n1) 1) \"OK\"\n127.0.0.1:6379> ZEESQL.EXEC DB02 COMMAND \"select * from foo\"\n(error) no such table: foo\n127.0.0.1:6379> ZEESQL.COPY FROM DB01 TO DB02\n1) 1) \"OK\"\n127.0.0.1:6379> ZEESQL.EXEC DB02 COMMAND \"select * from foo\"\n1) 1) \"RESULT\"\n2) 1) \"a\"\n   2) \"b\"\n3) 1) \"INT\"\n   2) \"INT\"\n4) 1) (integer) 1\n   2) (integer) 2\n5) 1) (integer) 3\n   2) (integer) 4  In the example we create a database, we create a table, and then we pushed few rows into the table.  We then create another database, but this time we didn't create the table, neither pushed any row.  As expected, trying to query the second database returned an error.  After copying the content of the first database into the second, the second database has become a perfect copy of the first one.  See also :   Backup API",
            "title": "ZEESQL.COPY"
        },
        {
            "location": "/references/#zeesqlindex",
            "text": "The index command accepts 3 different options:   NEW  LIST  DELETE   We will illustrate them separately.",
            "title": "ZEESQL.INDEX"
        },
        {
            "location": "/references/#zeesqlindex-new",
            "text": "ZEESQL.INDEX db_key \n    NEW\n    TABLE table_name\n    [PREFIX prefix]\n    SCHEMA column_name column_type [column_name column_type ...]  Creates a new secondary index table for the Redis hashes.  The secondary index will refer to the table  table_name  and will use the columns indicated in the  SCHEMA  parameter.  column_type  can be whatever is accepted by SQLite as column name, suggestions are  TEXT ,  INT ,  FLOAT  or  BLOB .  If a prefix is provided, only the Redis hashes that start with that prefix are indexed in the table.\nIf the prefix is omitted, the  *  prefix (catch-all) is assumed.  If the table does not exists when the index is created,  zeeSQL  creates it.  If the table already exists,  zeeSQL  takes no action.\nHowever, if the table exists but contains the wrong columns,  zeeSQL  may find it impossible to insert the hashes into the secondary index.  It is possible to create multiple indexes, with the same table, same schema, but different prefix.  zeeSQL  store in the secondary index table, the main Redis hash key, as primary key.  The table created by  zeeSQL  behaves like any other table, so it can be queried, modified, and indexed, using the standard  ZEESQL.EXEC  interface.  No steps are taken to avoid manual deletions or updates of the secondary index table by the user.  Secondary indexes are univocally identified by the combination of the table in which they write and the prefix.  Example :  In this example, we can see how to create a secondary index, and how the secondary index automatically keeps the values between Redis and zeeSQL in synchronism.  127.0.0.1:6379> ZEESQL.INDEX DB NEW TABLE users prefix user:* SCHEMA username STRING score INT\nOK\n127.0.0.1:6379> HMSET user:1001 username aaa score 0\nOK\n127.0.0.1:6379> HMSET user:1002 username bbb score 0\nOK\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND \"select * from users\"\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"username\"\n   3) \"score\"\n3) 1) \"TEXT\"\n   2) \"TEXT\"\n   3) \"INT\"\n4) 1) \"user:1001\"\n   2) \"aaa\"\n   3) (integer) 0\n5) 1) \"user:1002\"\n   2) \"bbb\"\n   3) (integer) 0\n127.0.0.1:6379> HINCRBY user:1002 score 3\n(integer) 3\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND \"select * from users\"\n1) 1) \"RESULT\"\n2) 1) \"key\"\n   2) \"username\"\n   3) \"score\"\n3) 1) \"TEXT\"\n   2) \"TEXT\"\n   3) \"INT\"\n4) 1) \"user:1001\"\n   2) \"aaa\"\n   3) (integer) 0\n5) 1) \"user:1002\"\n   2) \"bbb\"\n   3) (integer) 3",
            "title": "ZEESQL.INDEX NEW"
        },
        {
            "location": "/references/#zeesqlindex-list",
            "text": "The list option shows the active secondary index.  The secondary indexes are identified by the table in which they write and by the prefix they use to filter the keys.  Example :  127.0.0.1:6379> ZEESQL.INDEX DB LIST\n1) 1) \"RESULT\"\n2) 1) \"users\"\n   2) \"user:*\"\n127.0.0.1:6379> ZEESQL.INDEX DB NEW TABLE games prefix games:* SCHEMA first_player STRING second_player STRING score_player_1 INT score_player_2 INT\nOK\n127.0.0.1:6379> ZEESQL.INDEX DB LIST\n1) 1) \"RESULT\"\n2) 1) \"users\"\n   2) \"user:*\"\n3) 1) \"games\"\n   2) \"games:*\"",
            "title": "ZEESQL.INDEX LIST"
        },
        {
            "location": "/references/#zeesqlindex-delete",
            "text": "ZEESQL.INDEX db_key \n    DELETE\n    TABLE table_name\n    [PREFIX prefix]  The  DELETE  option removes a secondary index.  Hashes that match the prefix are not inserted anymore in the table after the index is removed.  The  DELETE  option takes as input the table and the prefix that identifies the secondary index to remove.  If the prefix is omitted the  *  (catch-all) prefix is assumed.  Example :  127.0.0.1:6379> ZEESQL.INDEX DB NEW TABLE users PREFIX user:* SCHEMA username STRING score INT\nOK\n127.0.0.1:6379> HMSET user:1001 username first_user score 12\nOK\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND \"select * from users\" NO_HEADER\n1) 1) \"RESULT\"\n2) 1) \"user:1001\"\n   2) \"first_user\"\n   3) (integer) 12\n127.0.0.1:6379> ZEESQL.INDEX DB DELETE TABLE users PREFIX user:*\n1) 1) \"DONE\"\n2) 1) (integer) 1\n127.0.0.1:6379> HMSET user:1002 username second_user score 5\nOK\n127.0.0.1:6379> ZEESQL.EXEC DB COMMAND \"select * from users\" NO_HEADER\n1) 1) \"RESULT\"\n2) 1) \"user:1001\"\n   2) \"first_user\"\n   3) (integer) 12  In the example, we first create an index.  Then we add a Redis hash that matches the secondary index prefix, so it is added to the secondary index table.  Then, delete the index.  And we can confirm that new users are not added any more to the secondary index table.",
            "title": "ZEESQL.INDEX DELETE"
        },
        {
            "location": "/references/#zeesqllicense",
            "text": "ZEESQL.LICENSE\n    ( SET \"license\" ) | SHOW  The  SET  option will set the license to use for  zeeSQL .  The license is first checked against our backend server, and if the license is correct, it will return  OK  otherwise it will return an error.  It is required an internet connection to set the license.  The  SHOW  option will show the license that is actually in use in your  zeeSQL  process.",
            "title": "ZEESQL.LICENSE"
        }
    ]
}